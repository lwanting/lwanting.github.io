<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue项目部署上线</title>
    <url>/2021/05/11/Vue/Vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ol>
<li>阿里云服务器（CentOS）</li>
<li>域名解析</li>
<li><a href="https://www.netsarang.com/zh/xftp/" target="_blank" rel="noopener">Xftp</a>、<a href="https://www.netsarang.com/zh/xshell/" target="_blank" rel="noopener">Xshell</a></li>
<li>安装PM2</li>
<li>安装Nginx</li>
</ol>
<a id="more"></a>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名-解析-添加记录 ，由于只有一个域名且一级域名已经使用，所以这里使用二级域名。</p>
<p><a href="https://imgchr.com/i/0P3eIg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/26/0P3eIg.png" alt="0P3eIg.png"></a></p>
<p><a href="https://help.aliyun.com/knowledge_detail/29725.html?spm=a2c6h.13066369.0.0.c2121ac6YXFk1F&source=5176.11533457&userCode=ywqc0ubl&type=copy" target="_blank" rel="noopener">参考文档</a></p>
<h2 id="Vue项目打包"><a href="#Vue项目打包" class="headerlink" title="Vue项目打包"></a>Vue项目打包</h2><p>打包命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>打包完成后，项目的根目录下会生成一个 <code>dist</code> 文件夹，使用Xftp将<code>dist</code>文件上传到云服务器。</p>
<h2 id="配置PM2"><a href="#配置PM2" class="headerlink" title="配置PM2"></a>配置PM2</h2><p><a href="https://lwanting.github.io/2020/09/30/PM2/" target="_blank" rel="noopener">介绍及使用</a></p>
<p>将API项目上传至云服务器，使用PM2启动进程并保持在线。</p>
<h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p><a href="https://lwanting.github.io/2020/09/30/Nginx/" target="_blank" rel="noopener">介绍及使用</a></p>
<p>在<code>/etc/nginx/conf.d/</code>目录下新建<code>music.conf</code>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen   80;</span><br><span class="line">    server_name  music.zwmuzhi.cn;</span><br><span class="line"></span><br><span class="line">    gzip on;   # 开启gzip</span><br><span class="line">    gzip_buffers 4 16k;  # 压缩所需缓冲区大小</span><br><span class="line">    gzip_comp_level 6;   # 压缩级别，数值越大压缩效果越好，效率越低</span><br><span class="line">    gzip_min_length 1k;  # 文件大于1k才压缩</span><br><span class="line">    gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;xml text&#x2F;javascript;   # 压缩的文件类型</span><br><span class="line">    gzip_vary on;   # 增加响应头Vary: Accept-Encoding</span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">    root   &#x2F;usr&#x2F;local&#x2F;vue-project&#x2F;music;   # vue项目的打包后的dist</span><br><span class="line">    index  index.html;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;api &#123;     # 当请求跨域时配置端口转发</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;;  # 后台服务地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>vue-router</code>有<code>hash</code>和<code>history</code>两种模式，不同的模式对应<code>nginx</code>的配置不同。<code>hash</code>模式下，上述配置即可，<code>history</code>模式下添加<code>try_files</code>。<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">参考文档</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">	index  index.html;</span><br><span class="line">	try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改配置后，重新加载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>浏览器中可以通过二级域名成功访问项目即配置成功。</p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>code review技巧</title>
    <url>/2021/04/18/code-review%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>1.pull request合入的目标分支是否正确。</p>
<p>2.若为bugfix。</p>
<ul>
<li>是否找到真正的root cause。</li>
<li>所采取的solution是什么，是否能真正解决该问题。</li>
<li>使用这种solution是否会导致新的问题，或是重现旧问题。<a id="more"></a></li>
<li>解决方法是否为最佳方法，是否存在其它更好的解决方法。</li>
<li>是否有边缘情况未考虑到。</li>
</ul>
<p>3.pull request中是否包含与当前任务无关的代码改动。</p>
<p>4.是否存在错别字、缩进、未删除调试代码或无用注释等低级错误。</p>
<p>5.是否存在重复代码或重复的模式。</p>
<p>6.命名是否符合规范。</p>
<ul>
<li>类名和对象名应是名词或名词短语</li>
<li>方法名应是动词或动词短语</li>
<li>做到见名知意</li>
<li>不要出现“自己造的缩写”</li>
</ul>
<p>7.若一次pull request改动过大，是否可以拆分为多次提交。</p>
<p>8.代码逻辑是否清楚，前后端分离。</p>
<p>9.是否存在执行效率较低、不符合阅读逻辑、不美观的写法。</p>
<p>10.函数是否符合规范。</p>
<ul>
<li>函数不应过长</li>
<li>函数参数最多尽量不要超过4个</li>
<li>分隔指令与询问（要么做什么事，要么回答什么事，二者不可得兼）</li>
</ul>
<p>11.对外部工具的调用是否有必要。</p>
<p>12.是否有用到不常用的系统接口、浏览器接口，接口兼容性如何。</p>
<p>13.代码改动是否会引发安全漏洞。</p>
<p>14.是否引入了不必要的数据库读写操作。</p>
<p>15.改动是否会让现有的行为失效。</p>
<p>16.是否编写了相对应的单元测试。</p>
]]></content>
      <categories>
        <category>技术修养</category>
      </categories>
  </entry>
  <entry>
    <title>如何寻求技术支持</title>
    <url>/2021/04/17/%E5%A6%82%E4%BD%95%E5%AF%BB%E6%B1%82%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>在开发过程中，不可避免的会遇到一些自己无法解决的问题，需要寻求技术支持。通常会写邮件，或是使用github的issues等，提供充分的信息并合理地阐述有利于问题的快速解决。以下是我总结的寻求技术支持时需要注意的几点：</p>
<a id="more"></a>

<h3 id="简要的标题"><a href="#简要的标题" class="headerlink" title="简要的标题"></a>简要的标题</h3><p>标题简要的总结所遇到的问题，有助于对方在详细阅读前大致了解你的问题。不要不写标题或是写没有意义的东西，如“我遇到了一个问题，能不能帮帮我”。如果比较紧急，也可以在标题中突出紧急（不能只突出紧急）。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>1.正文中尽可能详细的描述所遇到的问题，会产生什么现象，是否有报错以及报错的详情。可以附上相关截图或是录屏，帮助对方更好的理解你遇到的问题。<br>2.分步骤描述如何复现该问题。<br>3.写出你有做过哪些尝试，以及得到的结果，并附上查到的资料。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>写出当前出现问题的环境，浏览器、操作系统以及各种工具的版本。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>避免出现大段的文字描述，大段文字并不会让人有看下去的欲望。注意条理性，语言简洁，分段分条说明。需要强调的地方可以加粗表示。</p>
<p>参考文章：<a href="https://www.renegade-empire.com/how-to-request-support-that-gets-solved-faster/" target="_blank" rel="noopener">https://www.renegade-empire.com/how-to-request-support-that-gets-solved-faster/</a></p>
]]></content>
      <categories>
        <category>技术修养</category>
      </categories>
  </entry>
  <entry>
    <title>移动端布局02-Flex布局</title>
    <url>/2021/04/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%8002-Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="与传统布局对比"><a href="#与传统布局对比" class="headerlink" title="与传统布局对比"></a>与传统布局对比</h3><p>传统布局：兼容性好、布局繁琐、有局限性(移动端表现不好)。</p>
<p>flex弹性布局：操作方便、布局简单、对PC端浏览器支持较差。</p>
<a id="more"></a>

<h3 id="布局原理"><a href="#布局原理" class="headerlink" title="布局原理"></a>布局原理</h3><p><img src="https://s1.ax1x.com/2020/07/21/UI7tdf.png" alt=""></p>
<p>Flex (Flexible Box)弹性布局，用来为盒模型提供最大的灵活性，任何一个容器都可以指定为Flex 布局。为父盒子设定Flex 布局后，子元素的<code>float</code>、<code>clear</code>、<code>vertical-align</code>属性都将失效。</p>
<p>采用Flex布局的元素，称为Flex 容器 (flex container)，简称“容器”。它所有的子元素自动称为容器成员，称为Flex 项目(flex item)，简称“项目”</p>
<p>总结：flex布局就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式。</p>
<h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>
<p>注意： 主轴和侧轴是会发生改变的，<code>flex-direction</code>设置谁为主轴，剩下的就是侧轴，子元素跟随主轴排列。</p>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
<h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。使用之前需要先确定好主轴。</p>
<ul>
<li><code>flex-start</code>（默认值）：从头部开始排列，若主轴是水平方向，则为左对齐。</li>
<li><code>flex-end</code>：从尾部开始排列，若主轴是水平方向，则为右对齐。</li>
<li><code>center</code>： 居中。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
</ul>
<h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义了如果一条轴线排不下，如何换行。</p>
<ul>
<li><code>nowrap</code>（默认值）：不换行，容器宽度不够时，会缩小项目宽度。</li>
<li><code>wrap</code>：换行，第一行在上方。</li>
<li><code>wrap-reverse</code>：换行，第一行在下方。</li>
</ul>
<h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><p><code>align-items</code>属性定义项目在侧轴上如何对齐。在项目为单项（单行）是使用。</p>
<ul>
<li><code>flex-start</code>：侧轴的起点对齐。</li>
<li><code>flex-end</code>：侧轴的终点对齐。</li>
<li><code>center</code>：侧轴的中点对齐（居中）。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：拉伸，如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<ul>
<li><code>flex-start</code>：与侧轴的起点对齐。</li>
<li><code>flex-end</code>：与侧轴的终点对齐。</li>
<li><code>center</code>：与侧轴的中点对齐。</li>
<li><code>space-between</code>：与侧轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
<blockquote>
<p><code>align-items</code>与<code>align-content</code>区别：<br><code>align-items</code>适用于单行情况下，只有上对齐、下对齐、居中和拉伸属性。<br><code>align-content</code>适用于多行(换行)的情况下，有上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</p>
</blockquote>
<h3 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>
<h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p>flex属性定义项目分配剩余空间，用flex表示占几份，默认值为0。</p>
<h3 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">属性值：auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure>

<h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>移动端布局</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode Git History插件</title>
    <url>/2020/12/06/VScode-Git-History%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Git History插件可以直观的查看相关文件的提交历史。</p>
<a id="more"></a>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在VScode应用商店中搜索并下载。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>选中需要查看的文件，右键-&gt;Git: View File History。</p>
<p>View file content：仅浏览文件内容</p>
<p>Compare file with current workspace file：与当前工作区的文件对比</p>
<p>Compare file with previous commit：与上一次提交的文件对比</p>
<p>View file history：浏览文件的修改历史</p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/2020/12/06/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="查看修改内容"><a href="#查看修改内容" class="headerlink" title="查看修改内容"></a>查看修改内容</h2><p>查看文件修改的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff [file name]</span><br></pre></td></tr></table></figure>

<p>查看工作区和版本库里面最新版本的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff HEAD -- [file name]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>丢弃工作区修改的内容，回到最近一次<code>git add</code>或是<code>git commit</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- [file name]</span><br></pre></td></tr></table></figure>

<p>添加到暂存区后想丢弃修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD [file name]</span><br></pre></td></tr></table></figure>

<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul>
<li>用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard [commit_id]</span><br></pre></td></tr></table></figure>

<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm [file name]</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>

<p>如果误删，从版本库中恢复文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- [file name]</span><br></pre></td></tr></table></figure>

<h2 id="关联远程库"><a href="#关联远程库" class="headerlink" title="关联远程库"></a>关联远程库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@server-name:path&#x2F;repo-name.git</span><br></pre></td></tr></table></figure>

<p>第一次推送master分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>之后推送master分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>查看所有分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>创建分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch [branch]</span><br></pre></td></tr></table></figure>

<p>切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout [branch]</span><br><span class="line">或</span><br><span class="line">git switch [branch]</span><br></pre></td></tr></table></figure>

<p>创建并切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch]</span><br><span class="line">或</span><br><span class="line">git switch -c [branch]</span><br></pre></td></tr></table></figure>

<p>删除分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d [branch]</span><br><span class="line">git branch -D [branch]  &#x2F;&#x2F; 强行删除没有被合并过的分支</span><br></pre></td></tr></table></figure>

<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>合并指定分支到当前分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure>

<p>git一般会使用<code>fast forward</code>模式合并，即修改指针完成合并，但是删除分之后无法查到合并记录，使用普通模式合并，合并后的历史可以查到合并记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; [branch]</span><br></pre></td></tr></table></figure>

<p>查看分支合并图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure>

<h3 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h3><p>一个分支上存在没有提交的文件，但需要转到另一个分支上处理时，保存现场</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<p>查看存储列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<p>恢复并删除<code>stash</code>内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;num&#125;   &#x2F;&#x2F; 恢复现场</span><br><span class="line">git stash drop stash@&#123;num&#125;    &#x2F;&#x2F; 删除现场</span><br><span class="line">或</span><br><span class="line">git stash pop  &#x2F;&#x2F; 弹出栈顶现场并删除</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<br><code>stash</code>并不会保存<code>untracked file</code>，使用之前记得<code>git status</code>确认没有<code>untracked file</code>。<br>谨慎使用<code>stash</code>，可能会丢失修改。</p>
</blockquote>
<h3 id="复制提交"><a href="#复制提交" class="headerlink" title="复制提交"></a>复制提交</h3><p>在另一个分支上提交后，可以将此次提交复制到当前分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>

<h3 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h3><p>查看远程库的详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>向远程库推送分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin [branch]</span><br></pre></td></tr></table></figure>

<p>创建远程的分支到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b dev origin&#x2F;[branch]</span><br></pre></td></tr></table></figure>

<p>远程分支领先于本地分支时，抓取远程的新提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to [branch] origin&#x2F;[branch]</span><br></pre></td></tr></table></figure>

<h3 id="拉取远端分支同时新建本地分支"><a href="#拉取远端分支同时新建本地分支" class="headerlink" title="拉取远端分支同时新建本地分支"></a>拉取远端分支同时新建本地分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gco --track origin&#x2F;bugfix</span><br></pre></td></tr></table></figure>

<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要先进入到需要同步的分支</span><br><span class="line">git pull origin hotfix   &#x2F;&#x2F; 拉取远端分支</span><br><span class="line">&#x2F;&#x2F; 切换到冲突的分支</span><br><span class="line">git rebase hotfix   &#x2F;&#x2F; 整合分叉的分支</span><br><span class="line">&#x2F;&#x2F; 文件内修改冲突</span><br><span class="line">git add .  &#x2F;&#x2F; 将更改加入本地库</span><br><span class="line">git rebase --continue  </span><br><span class="line">&#x2F;&#x2F; 如果出现问题</span><br><span class="line">git rebase --skip</span><br><span class="line">git push xxx :[branch]   &#x2F;&#x2F; 删除远端分支</span><br><span class="line">git push xxx [branch]   &#x2F;&#x2F; 重新push</span><br></pre></td></tr></table></figure>
<p>rebase变基，即改变基本。</p>
<h2 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log  &#x2F;&#x2F; 查看提交历史</span><br><span class="line">git rebase -i [hash]  &#x2F;&#x2F; hash值对应最新一个想要保留的commit</span><br><span class="line">&#x2F;&#x2F; 编辑文件</span><br><span class="line">&#x2F;&#x2F; s表示该commit会合并到前一个commit</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<h2 id="本地库和远端库不同步"><a href="#本地库和远端库不同步" class="headerlink" title="本地库和远端库不同步"></a>本地库和远端库不同步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log master..origin&#x2F;master  &#x2F;&#x2F; 比较本地与远端的差异</span><br><span class="line">git diff --start master origin&#x2F;master  &#x2F;&#x2F; 统计文件的改动</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 记录commit码</span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin&#x2F;hotfix</span><br><span class="line">&#x2F;&#x2F; 进入新的分支</span><br><span class="line">git cherry-pick [commit码]</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin hotfix</span><br><span class="line">gir rebase origin&#x2F;hotfix</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<h2 id="查看文件修改情况"><a href="#查看文件修改情况" class="headerlink" title="查看文件修改情况"></a>查看文件修改情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git blame [文件路径]</span><br><span class="line">git show [commit码]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>PM2</title>
    <url>/2020/09/30/PM2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PM2是node进程管理工具，它可以管理和保持应用程序在线，支持性能监控，进程守护，负载均衡等功能。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>PM2依赖node和npm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装pm2</span><br><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>启动进程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start app.js</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>--watch</code>：监听应用目录的变化，一旦发生变化，自动重启。</li>
<li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果<code>-i 0</code>或者<code>-i max</code>，则根据当前机器核数确定实例数目。</li>
<li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如<code>--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</code></li>
<li><code>-n --name</code>：应用的名称。查看应用信息的时候可以用到。</li>
<li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径。</li>
<li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径。</li>
</ul>
<p><strong>重启进程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 重启指定名称或id的进程</span><br><span class="line">pm2 restart [name or id]</span><br><span class="line">&#x2F;&#x2F; 重启所有进程</span><br><span class="line">pm2 restart all</span><br></pre></td></tr></table></figure>

<p><strong>停止进程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 停止指定名称或id的进程</span><br><span class="line">$ pm2 stop [name or id]</span><br><span class="line">&#x2F;&#x2F; 停止所有进程</span><br><span class="line">$ pm2 stop all</span><br></pre></td></tr></table></figure>

<p><strong>杀死进程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 杀死指定名称或id的进程</span><br><span class="line">$ pm2 delete [name or id]</span><br><span class="line">&#x2F;&#x2F; 杀死所有进程</span><br><span class="line">$ pm2 delete all</span><br></pre></td></tr></table></figure>

<p><strong>查看所有启动的进程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 list</span><br></pre></td></tr></table></figure>

<p><strong>查看进程日志</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看指定名称或id的进程的日志</span><br><span class="line">pm2 logs [name or id]</span><br><span class="line">&#x2F;&#x2F; 查看所有进程的日志</span><br><span class="line">pm2 logs all</span><br></pre></td></tr></table></figure>

<p><strong>开机自动启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 startup</span><br></pre></td></tr></table></figure>

<p>将生成的开机自启动命令粘贴到控制台执行并保存设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 save</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ol>
<li><a href="https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/</a></li>
<li><a href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/p/pm2-documentation.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>PM2</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2020/09/30/Nginx/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Nginx是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like协议下发行，可以在UNIX、GNU/Linux、BSD、Mac OS X、Solaris，以及Microsoft Windows等操作系统中运行。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载nginx-1.18.0.tar.gz 安装包，将其放在root⽬录下。</p>
<p>1、安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install  pcre pcre-devel -y </span><br><span class="line">yum install openssl openssl-devel -y</span><br></pre></td></tr></table></figure>

<p>2、将Nginx安装包解压到 <code>/usr</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf &#x2F;root&#x2F;nginx-1.18.0.tar.gz -C .&#x2F;</span><br></pre></td></tr></table></figure>

<p>3、编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nginx-1.18.0&#x2F;</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure>

<p>其他命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload            # 重新载入配置文件，不重启进程，不会停止处理请求</span><br><span class="line">nginx -s stop              # 停止 Nginx</span><br><span class="line">nginx -t                   # 检查配置文件语法</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>主配置文件<code>/etc/nginx/nginx.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1; # 设置值和CPU核心数一致</span><br><span class="line"></span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;  # 错误日志</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;  # nginx守护进程的pid文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;  # 每个进程能够接受的最大连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main; # 自定义服务日至</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; # 配置文件的引入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一台服务器配置多个网站，如果配置都写在主配置文件中，会导致主配置文件体积变大，可读性降低。所以需要分离配置文件，<code>include /etc/nginx/conf.d/*.conf;</code>表示引入了<code>/etc/nginx/conf.d/</code>下所有以<code>.conf</code>文件结尾的文件，该目录下的配置文件只需要有<code>server</code>级。</p>
<p>参考资料：<a href="https://www.jianshu.com/p/d8bd75c0fb1b" target="_blank" rel="noopener">https://www.jianshu.com/p/d8bd75c0fb1b</a></p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>good-storage插件</title>
    <url>/2020/09/25/good-storage%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用<code>good-storge</code>插件在缓存中读写数据，因为原生的<code>localStorage</code>中的键值对总是以字符串的形式存储，存储数组时需要进行频繁的格式转换。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install good-storage</span><br></pre></td></tr></table></figure>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import storage from &#39;good-storage&#39;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// localStorage</span></span><br><span class="line">storage.set(key,val) </span><br><span class="line">storage.get(key, def)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// sessionStorage</span></span><br><span class="line">storage.session.set(key, val)</span><br><span class="line">storage.session.get(key, val)</span><br></pre></td></tr></table></figure>

<p>API：</p>
<ol>
<li><p><code>set(key, val)</code></p>
<p>以键值对的形式存储。</p>
</li>
<li><p><code>get(key, def)</code></p>
<p>用键获取值，若没有找到，则赋值为def。</p>
</li>
<li><p><code>remove(key)</code></p>
<p>移除键对应的存储记录。</p>
</li>
</ol>
<p><a href="https://www.npmjs.com/package/good-storage" target="_blank" rel="noopener">参考文档</a></p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>storge</tag>
      </tags>
  </entry>
  <entry>
    <title>全屏插件screenfull.js</title>
    <url>/2020/09/25/%E5%85%A8%E5%B1%8F%E6%8F%92%E4%BB%B6screenfull-js/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>screenfull.js是用于跨浏览器使用JavaScript <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fullscreen_API" target="_blank" rel="noopener">Fullscreen API</a>的简单包装器，可让将页面或任何元素全屏显示，并且平滑浏览器实现差异。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install screenfull --save</span><br></pre></td></tr></table></figure>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import screenfull from &#39;screenfull&#39;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>方法：</p>
<ol>
<li><p><code>.request()</code></p>
<p>使元素全屏显示，默认为<code>&lt;html&gt;</code>。</p>
</li>
<li><p><code>.exit()</code></p>
<p>退出全屏。</p>
</li>
<li><p><code>.toggle()</code></p>
<p>当前处于全屏状态则退出全屏，否则，全屏显示。</p>
</li>
</ol>
<p>属性：</p>
<ol>
<li><p><code>.isFullscreen</code></p>
<p>返回布尔值，表示当前是否处于全屏状态。</p>
</li>
<li><p><code>.element</code></p>
<p>返回当前全屏的元素，若无则返回null。</p>
</li>
<li><p><code>.isEnabled</code></p>
<p>返回布尔值，表示是否允许全屏。如果页面处于<code>&lt;iframe&gt;</code>标签内，则需要添加<code>allowfullscreen</code>属性。</p>
</li>
</ol>
<p><a href="https://github.com/sindresorhus/screenfull.js/" target="_blank" rel="noopener">参考文档</a></p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>时间处理插件Moment.js</title>
    <url>/2020/09/25/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E6%8F%92%E4%BB%B6Moment-js/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Moment.js是一个简单易用的轻量级JavaScript日期处理类库，提供了日期格式化、日期解析等功能。它支持在浏览器和NodeJS两种环境中运行。此类库能够将给定的任意日期转换成多种不同的格式，具有强大的日期计算功能，同时也内置了能显示多样的日期形式的函数。Moment.js支持多种语言。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install moment --save</span><br></pre></td></tr></table></figure>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import moment from &#39;moment&#39;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>组件内使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = moment().format()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在过滤器中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'formatDate'</span>, (date, pattern = <span class="string">'YYYY-MM-DD HH:mm:ss'</span>) =&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> moment(date).format(pattern)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123; time | formatDate(<span class="string">'YYYY-MM-DD'</span>) &#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><a href="http://momentjs.cn/docs/" target="_blank" rel="noopener">参考文档</a></p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript笔记05-补充</title>
    <url>/2020/08/12/JavaScript%E7%AC%94%E8%AE%B005-%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h2 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><p>创建对象有三种方法：</p>
<ul>
<li>对象字面量</li>
<li>new Object()</li>
<li>自定义构造函数</li>
</ul>
<a id="more"></a>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值。可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里。</p>
<ul>
<li>构造函数用于创建某一类对象，首字母要大写</li>
<li>构造函数要和<code>new</code>一起使用才有意义</li>
</ul>
<p><code>new</code>的执行过程：</p>
<ul>
<li>在内存中创建一个空对象。</li>
<li>让<code>this</code>指向这个新的对象。</li>
<li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li>
<li>返回这个新对象（所以构造函数里面不需要<code>return</code>）。</li>
</ul>
<p>构造函数的<strong>成员</strong>：</p>
<ul>
<li>静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问 。</li>
<li>实例成员：在构造函数内部通过<code>this</code>创建的对象成员称为实例成员，只能由实例化的对象来访问。</li>
</ul>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>构造函数给每个实例对象都开辟了一个独立的内存空间，会存在浪费内存的问题。</p>
<p>JavaScript 规定，每一个构造函数都有一个<code>prototype</code>属性,这个<code>prototype</code>是一个对象，该对象的所有属性和方法，都会被构造函数所拥有。把那些不变的方法直接定义在<code>prototype</code>对象上，这样所有对象的实例就都可以共享这些方法。</p>
<p><strong>扩展内置对象</strong></p>
<p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p>
<blockquote>
<p>注意：</p>
<p>数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p>
</blockquote>
<h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 _proto_"></a>对象原型 _<em>proto_</em></h3><p>对象都会有一个属性<code>__proto__</code>指向构造函数的<code>prototype</code>原型对象，对象可以使用构造函数<code>prototype</code>原型对象的属性和方法，就是因为对象有<code>__proto__</code>原型的存在。</p>
<ul>
<li><code>__proto__</code>对象原型和原型对象<code>prototype</code>是等价的</li>
<li><code>__proto__</code>对象原型的意义在于为对象的查找机制提供一个方向，但它是一个非标准属性，实际开发中不可以使用这个属性，只是内部指向原型对象<code>prototype</code>。</li>
</ul>
<p><strong>成员查找机制</strong></p>
<ul>
<li>访问一个对象的属性或方法时，首先查找这个对象自身有没有该属性。</li>
<li>如果没有就查找它的原型，也就是 <code>__proto__</code>指向的<code>prototype</code>原型对象。</li>
<li>如果还没有就查找原型对象的原型。</li>
<li>依此类推一直找到 Object 为止（null）。</li>
</ul>
<h3 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h3><p>对象原型<code>__proto__</code>和构造函数原型对象<code>prototype</code>里都有一个<code>constructor</code>属性，称为构造函数，它指向构造函数本身。</p>
<p><code>constructor</code>主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p>
<p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，可以给原型对象采取<strong>对象形式</strong>赋值，这样就会<strong>覆盖</strong>构造函数原型对象原来的内容，而修改后的原型对象<code>constructor</code>就不再指向当前构造函数了。此时，需要在修改后的原型对象中，添加一个<code>constructor</code>指向原来的构造函数。</p>
<h3 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h3><img src="https://s1.ax1x.com/2020/08/07/aWG0nP.png" style="zoom:50%; margin-left:0;" />

<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><img src="https://s1.ax1x.com/2020/08/07/aWtsAK.png" style="zoom:50%; margin-left:0;" />

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过构造函数+原型对象模拟实现继承，称为组合继承。</p>
<p><strong>call()</strong></p>
<p><code>call()</code>调用函数, 并且修改函数运行时的<code>this</code>指向   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thisArg ：当前调用函数 this 的指向对象</span></span><br><span class="line"><span class="comment">// arg1，arg2：传递的其他参数</span></span><br><span class="line">func.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>通过<code>call()</code>把父类型的<code>this</code>指向子类型的<code>this</code>，这样就可以实现子类型继承父类型的属性。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此时父类的 this 指向子类的 this，同时调用这个函数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age, sex);</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">'zs'</span>, <span class="number">18</span>, <span class="string">'男'</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p><strong>组合继承</strong></p>
<ul>
<li>让子类的原型对象<code>prototype = new 父类()</code> </li>
<li>子类原型对象指向父类的实例对象，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</li>
<li>由于以对象形式修改了子类原型对象，所以需要将子类的<code>constructor</code>重新指向子类的构造函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">100000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>, uname, age);</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype;  直接赋值若修改了子原型对象,父原型对象也会跟着一起变化</span></span><br><span class="line"><span class="comment">// 子类原型对象指向父类的实例对象</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 使用 constructor 指回原来的构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'zs'</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong>寄生组合继承</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">100000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>, uname, age);</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype;  直接赋值若修改了子原型对象,父原型对象也会跟着一起变化</span></span><br><span class="line"><span class="comment">// 子类原型对象指向父类的实例对象</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line"><span class="comment">// 使用 constructor 指回原来的构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'zs'</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>组合继承和寄生组合继承的<strong>区别</strong>：</p>
<ul>
<li>组合继承在将子类原型对象指向父类实例后，子类原型对象中也拥有了父类的属性，此时子类实例和原型对象中都拥有<code>uname</code>和<code>age</code>属性，如果删除实力上的<code>uname</code>属性，实际上还能访问到原型上的属性。</li>
<li>寄生组合继承中<code>Object.create(Father.prototype)</code>返回一个以<code>Father.prototype</code>为原型的对象，不执行<code>Father</code>方法，所以子类原型对象中不会存在<code>uname</code>和<code>age</code>属性。</li>
<li>寄生组合继承比组合继承更合理。</li>
</ul>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[, index, arr]</span>))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>currentValue：数组当前项的值</li>
<li>index：数组当前项的索引</li>
<li>arr：数组对象本身</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[,index,arr]</span>))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>currentValue：数组当前项的值</li>
<li>index：数组当前项的索引</li>
<li>arr：数组对象本身</li>
</ul>
<p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p>
<blockquote>
<p>注意：map() 不会对空数组进行检测且不会改变原始数组。</p>
</blockquote>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[, index, arr]</span>))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>currentValue: 数组当前项的值</li>
<li>index：数组当前项的索引</li>
<li>arr：数组对象本身</li>
</ul>
<p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组。</p>
<blockquote>
<p>注意：filter() 方法直接返回一个新数组。 </p>
</blockquote>
<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[, index, arr]</span>))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>currentValue: 数组当前项的值</li>
<li>index：数组当前项的索引</li>
<li>arr：数组对象本身</li>
</ul>
<p>some() 方法用于检测数组中的元素是否满足指定条件，即查找数组中是否有满足条件的元素。</p>
<blockquote>
<p>注意:</p>
<p>some() 方法返回值是布尔值，如果查找到这个元素，就返回true，否则返回false。</p>
<p>找到第一个满足条件的元素就终止循环，不再继续查找。</p>
</blockquote>
<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[, index, arr]</span>))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>currentValue: 数组当前项的值</li>
<li>index：数组当前项的索引</li>
<li>arr：数组对象本身</li>
</ul>
<p>every() 方法用于检测用于检测数组所有元素是否都符合指定条件。</p>
<blockquote>
<p>注意：</p>
<p>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</p>
<p>若所有元素都满足条件，则返回 true。</p>
</blockquote>
<h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br></pre></td></tr></table></figure>

<p>Object.keys()方法用于获取对象自身所有的属性。效果类似<code>for…in</code>，返回一个由属性名组成的<strong>数组</strong>。</p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<ul>
<li>obj：必需。要定义属性的对象。    </li>
<li>prop：必需。需定义或修改的属性的名字</li>
<li>descriptor：必需。目标属性所拥有的特性， 以对象形式<code>{ }</code>书写<ul>
<li>value: 设置属性的值  默认为undefined</li>
<li>writable: 值是否可以重写。true | false  默认为false</li>
<li>enumerable: 目标属性是否可以被枚举。true | false 默认为 false</li>
<li>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false  默认为false</li>
</ul>
</li>
</ul>
<h2 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><ol>
<li><p>函数声明方式<code>function</code>关键字 (命名函数)</p>
</li>
<li><p>函数表达式 (匿名函数)</p>
</li>
<li><p>new Function()，Function里的参数都必须是字符串格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'参数1'</span>,<span class="string">'参数2'</span>..., <span class="string">'函数体'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>总结：</p>
<ul>
<li>第三种方式执行效率低，也不方便书写，因此较少使用</li>
<li>所有函数都是Function的实例</li>
<li>函数也属于对象</li>
</ul>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><ol>
<li><p>普通函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn();</span><br><span class="line">fn.call();</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.fn();</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Obj()</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定事件函数</p>
<p>执行相应操作。</p>
</li>
<li><p>定时器函数</p>
<p>定时器自动调用。</p>
</li>
<li><p>立即执行函数</p>
<p>自动调用。</p>
</li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><table>
<thead>
<tr>
<th>调用方式</th>
<th>this指向</th>
</tr>
</thead>
<tbody><tr>
<td>普通函数</td>
<td>window</td>
</tr>
<tr>
<td>对象的方法</td>
<td>该方法所属对象</td>
</tr>
<tr>
<td>构造函数</td>
<td>实例对象，原型对象里的方法也指向实例对象</td>
</tr>
<tr>
<td>绑定事件函数</td>
<td>绑定事件对象</td>
</tr>
<tr>
<td>定时器函数</td>
<td>window</td>
</tr>
<tr>
<td>立即执行函数</td>
<td>window</td>
</tr>
</tbody></table>
<h3 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h3><p><strong>call()方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thisArg：在 fun 函数运行时指定的 this 值</span></span><br><span class="line"><span class="comment">// arg1，arg2：传递的其他参数</span></span><br><span class="line">func.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p><code>call()</code>方法参数为空时仅调用函数，指明参数可以改变函数内<code>this</code>的指向，主要用于实现继承。</p>
<p><strong>apply()方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thisArg：在fun函数运行时指定的 this 值</span></span><br><span class="line"><span class="comment">// argsArray：传递的值，必须包含在数组里面</span></span><br><span class="line">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>

<p><code>apply()</code>方法参数为空时仅调用函数，指明参数可以改变函数内<code>this</code>的指向，可以利用<code>apply()</code>借助数学内置对象求数组的最大最小值。</p>
<blockquote>
<p>注意：第二个参数必须为数组</p>
</blockquote>
<p><strong>bind()方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thisArg：在 fun 函数运行时指定的 this 值</span></span><br><span class="line"><span class="comment">// arg1，arg2：传递的其他参数</span></span><br><span class="line">func.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<p><code>bind()</code>方法不调用函数，返回一个<strong>原函数的拷贝</strong>，并拥有指定的 <code>this</code>值和初始参数。只想改变<code>this</code>指向，并不想调用这个函数的时候，可以使用<code>bind()</code>，如改变定时器内部<code>this</code>指向。</p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES5的严格模式是采用具有限制性JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。</p>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少了一些怪异行为。</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全。</li>
<li>提高编译器效率，增加运行速度。</li>
<li>禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字：class, enum, export, extends, import, super 不能做变量名。</li>
</ul>
<h3 id="调用严格模式"><a href="#调用严格模式" class="headerlink" title="调用严格模式"></a>调用严格模式</h3><p>严格模式可以应用到整个脚本或个别函数中。</p>
<p><strong>为脚本开启严格模式</strong>：</p>
<p>为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句 <code>&quot;use strict&quot;;</code> 或 <code>&#39;use strict&#39;;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> v = <span class="string">"strict mode"</span>;</span><br></pre></td></tr></table></figure>

<p><strong>为函数开启严格模式</strong>：</p>
<p>要给某个函数开启严格模式，需要把<code>&quot;use strict&quot;;</code> 或 <code>&#39;use strict&#39;;</code>声明放在函数体所有语句之前。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"strict mode"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notStrict</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="string">"not strict mode"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="严格模式中的变化"><a href="#严格模式中的变化" class="headerlink" title="严格模式中的变化"></a>严格模式中的变化</h3><p><strong>1.变量</strong></p>
<ul>
<li>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式中变量都必须<strong>先声明再使用</strong>。</li>
<li>严禁删除已经声明的变量。</li>
</ul>
<p><strong>2.this 指向</strong></p>
<ul>
<li>严格模式下全局作用域里函数中的<code>this</code>为<code>undefined</code>。</li>
<li>严格模式下，构造函数必须用<code>new</code>调用。</li>
<li><code>new</code>实例化的构造函数还是指向创建的对象实例。</li>
<li>定时器<code>this</code>还是指向 window 。</li>
<li>事件、对象还是指向调用者。</li>
</ul>
<p><strong>3.函数</strong></p>
<ul>
<li>函数不能有重名的参数。</li>
<li>函数必须声明在顶层。为了与新版本ES6接轨，不允许在非函数的代码块内 (如<code>for</code>,<code>if</code>) 声明函数。 </li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包（closure）指有权访问另一个函数作用域中变量的<strong>函数</strong>，即外部作用域可以访问一个函数内的局部变量。 换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p>闭包作用：延伸变量的作用范围。</p>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p><strong>浅拷贝</strong>只是拷贝一层, 更深层次对象级别的只拷贝引用。</p>
<p><strong>深拷贝</strong>拷贝多层, 每一级别的数据都会拷贝。</p>
<p>实现浅拷贝方法：</p>
<ol>
<li><p><code>for···in</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'zs'</span>,</span><br><span class="line">    msg: &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    o[k] = obj[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6新增<code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>实现深拷贝方法：</p>
<ol>
<li><p>递归拷贝每一层数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'zs'</span>,</span><br><span class="line">    msg: &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    hobbies: [<span class="string">'sing'</span>, <span class="string">'dance'</span>, <span class="string">'rap'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 封装函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">newObj, oldObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> oldobj) &#123;</span><br><span class="line">        <span class="comment">// 判断属性值属于那种数据类型</span></span><br><span class="line">        <span class="comment">// 1. 获取属性值  oldobj[k]</span></span><br><span class="line">        <span class="keyword">var</span> item = oldobj[k];</span><br><span class="line">        <span class="comment">// 2. 判断是否为数组</span></span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            newobj[k] = [];</span><br><span class="line">            deepCopy(newobj[k], item)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 判断是否为对象</span></span><br><span class="line">            newobj[k] = &#123;&#125;;</span><br><span class="line">            deepCopy(newobj[k], item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 简单数据类型</span></span><br><span class="line">            newobj[k] = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">deepCopy(o, obj);</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery的extend方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deep: Boolean类型 是否深度合并对象，默认为false。</span></span><br><span class="line"><span class="comment">// target: 目标对象，其他对象的成员属性将被附加到该对象上。</span></span><br><span class="line"><span class="comment">// object: 被合并对象</span></span><br><span class="line">$.extend( [deep ], target, object1 [, objectN ] )</span><br></pre></td></tr></table></figure>
</li>
<li><p>lodash函数库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = _.cloneDeep(oldObj)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>通过调用RegExp对象的构造函数创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/表达式/</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过字面量创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/表达式/</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>test()</code>方法用于检测字符串是否符合该规则，返回值为布尔值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/表达式/</span>; </span><br><span class="line">reg.test(str)</span><br></pre></td></tr></table></figure>

<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table>
<thead>
<tr>
<th align="center">特殊字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="left">匹配输入字符串的开始位置，当该符号在方括号表达式中使用时，表示取反。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串的结尾位置</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次（大于等于0）</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次（大于等于1）</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。（0 | 1）</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符 \n 之外的任何单字符</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">匹配n次</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">匹配n次或多次</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">匹配n到m次</td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">指明两项之间的一个选择（或选项）</td>
</tr>
</tbody></table>
<p>括号：</p>
<ul>
<li>大括号 量词符。表示重复次数</li>
<li>中括号 字符集合。匹配中括号中的任意字符，根据特殊字符决定匹配次数。</li>
<li>小括号 表示优先级，括号内的子表达式可以获取供以后使用。</li>
</ul>
<blockquote>
<p>注意：特殊字符匹配本身时，需要使用<code>\</code>进行转义。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">预定义类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\d</td>
<td>匹配一个数字字符。等价于 [0-9]</td>
</tr>
<tr>
<td align="center">\D</td>
<td>匹配一个非数字字符。等价于 [^0-9]</td>
</tr>
<tr>
<td align="center">\w</td>
<td>匹配字母、数字、下划线。等价于[A-Za-z0-9_]</td>
</tr>
<tr>
<td align="center">\W</td>
<td>匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]</td>
</tr>
<tr>
<td align="center">\s</td>
<td>匹配空白字符，包括空格、制表符、换页符等。等价于 [ \f\n\r\t\v]</td>
</tr>
<tr>
<td align="center">\S</td>
<td>匹配非空白字符。等价于 [^ \f\n\r\t\v]</td>
</tr>
</tbody></table>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>replace()</code> 方法可以实现替换字符串操作，替换的参数可以是字符串或正则表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">stringObject.replace(regexp/substr,replacement)</span><br></pre></td></tr></table></figure>

<p>返回值是替换完毕的新字符串。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/表达式/[<span class="keyword">switch</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>g：全局匹配 </li>
<li>i：忽略大小写 </li>
<li>gi：全局匹配 + 忽略大小写</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题记录</title>
    <url>/2020/08/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录面试过程中被问到的知识点</p>
<a id="more"></a>

<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>1、状态码</p>
<ul>
<li>1XX：信息状态码</li>
<li>2XX：成功状态码<ul>
<li><code>200 OK</code> 正常返回信息</li>
<li><code>201 Created</code> 请求成功并且服务器创建了新的资源</li>
<li><code>202 Accepted</code> 服务器已接受请求，但尚未处理</li>
</ul>
</li>
<li>3XX：重定向<ul>
<li><code>301 Moved Permanently</code> 请求的网页已永久移动到新位置。</li>
<li><code>302 Found</code> 临时性重定向。</li>
<li><code>303 See Other</code> 临时性重定向，且总是使用 <code>GET</code> 请求新的 <code>URL</code>。</li>
<li><code>304 Not Modified</code> 自从上次请求后，请求的网页未修改过。</li>
</ul>
</li>
<li>4XX：客户端错误<ul>
<li><code>400 Bad Request</code> 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li><code>401 Unauthorized</code> 请求未授权。</li>
<li><code>403 Forbidden</code> 禁止访问。</li>
<li><code>404 Not Found</code> 找不到如何与 `URL 相匹配的资源。</li>
</ul>
</li>
<li>5XX：服务器错误<ul>
<li><code>500 Internal Server Error</code> 最常见的服务器端错误。</li>
<li><code>503 Service Unavailable</code> 服务器端暂时无法处理请求（可能过载或维护）。</li>
</ul>
</li>
</ul>
<p>2、网站性能优化</p>
<ul>
<li>减少http请求次数：精灵图，JS、CSS源码压缩、控制图片大小，CDN托管，data缓存 ，图片服务器。</li>
<li>将样式表放在顶部，脚本放在底部。</li>
<li>图片预加载。</li>
<li>缓存DOM节点查找的结果，减少IO读取操作。</li>
</ul>
<p>3、浏览器中输入url到显示页面的步骤</p>
<p>简洁版：</p>
<ol>
<li>浏览器将url交给DNS服务器进行域名解析，找到真实的IP地址，向服务器发起请求</li>
<li>服务器返回处理后的数据，浏览器接收文件（HTML、JS、CSS、图像等）</li>
<li>浏览器对加载后的（HTML、JS、CSS等）资源进行语法解析，建立相应的内部数据结构（HTML、DOM等）</li>
<li>载入解析后的资源文件，完成页面的渲染<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2></li>
</ol>
<p>1、<code>&lt;!DOCTYPE&gt;</code> 的作用</p>
<p><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知 Web 浏览器页面使用了哪种 HTML 版本，用什么文档类型规范来解析这个文档。</p>
<p>2、介绍HTML5</p>
<p>新特性：</p>
<ul>
<li>用于绘画的 canvas 元素</li>
<li>新增多媒体标签 video 和 audio </li>
<li>对本地离线存储的更好的支持</li>
<li>新的特殊内容元素，如 article、footer、header、nav、section</li>
<li>新的表单控件，如 date、time、email、url、search</li>
</ul>
<p>3、Canvas</p>
<p>HTML5的canvas元素使用JavaScript在网页上绘制图像。画布是一个矩形区域，可以使用JavaScript控制其每一像素。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>1、盒模型</p>
<p>盒子模型构成：内容(<code>content</code>)、内边距(<code>padding</code>)、 边框(<code>border</code>)、外边距(<code>margin</code>)</p>
<ul>
<li>标准(<code>W3C</code>)盒模型： 元素宽度 = <code>width + padding + border + margin</code></li>
<li>怪异(<code>IE</code>)盒模型：元素宽度 = <code>width + margin</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span> </span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span></span><br></pre></td></tr></table></figure>

<p>2、选择器权重</p>
<p>优先级： <strong>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承</strong></p>
<p>3、动画animation</p>
<p><code>animation</code>是CSS3新增的属性，通过<code>@keyframes</code>声明动画的名称，通过<code>to</code>、<code>from</code>或百分比定义动画</p>
<table>
<thead>
<tr>
<th align="center"><strong>属性</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">@keyframes</td>
<td align="left">定义动画</td>
</tr>
<tr>
<td align="center">animation-name</td>
<td align="left">动画的名称（必写）</td>
</tr>
<tr>
<td align="center">animation-duration</td>
<td align="left">动画完成一个周期所花费的秒或毫秒，默认是0（必写）</td>
</tr>
<tr>
<td align="center">animation-timing-function</td>
<td align="left">动画的速度曲线，默认是ease</td>
</tr>
<tr>
<td align="center">animation-delay</td>
<td align="left">动画何时开始，默认是0</td>
</tr>
<tr>
<td align="center">animation-iteration-count</td>
<td align="left">动画播放的次数，默认是1，infinite无限播放</td>
</tr>
<tr>
<td align="center">animation-direction</td>
<td align="left">动画是否在下一周期逆向播放，默认是normal，alternate逆播放</td>
</tr>
<tr>
<td align="center">animation-play-state</td>
<td align="left">动画是否正在运行或暂停。默认是running，paused暂停</td>
</tr>
<tr>
<td align="center">animation-fill-mode</td>
<td align="left">动画结束后的状态，forwards停在结束位置，backwards回到起始位置</td>
</tr>
</tbody></table>
<p>使用animation简写所有动画属性，除了animation-play-state属性，书写顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation：动画名称 持续时间 运动曲线  何时开始  播放次数  是否反方向  动画起始或者结束的状态</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>1、事件代理，以及如何区分当前对象</p>
<p>事件代理又称为事件委托，将事件监听器设置在父节点上，利用冒泡原理进而影响每个子节点。</p>
<p>优点：给动态增加的子节点绑定事件，只操作了一次DOM，提高了程序性能。</p>
<p>通过<code>event.target</code>获得事件源，<code>event.srcElement</code>（IE 6-8）。</p>
<p>2、阻止冒泡和默认行为</p>
<p>阻止冒泡：<code>retutn false</code>，<code>event.stopPropagation()</code>（标准），<code>event.cancelBubble</code>（IE 6-8）</p>
<p>阻止默认行为：<code>return false</code>，<code>event.preventDefault()</code>（标准），`event.returnValue（IE 6-8）</p>
<p><code>return false</code> :</p>
<p>​    1.event.preventDefault()</p>
<p>​    2.event.stopPropagation()</p>
<p>​    3.停止回调函数执行并立即返回</p>
<p>3、捕获阶段</p>
<p>捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p>
<p>事件捕获：从DOM最顶层节点开始逐级向下传播到具体元素的过程</p>
<p>事件冒泡：从具体元素逐级向上传播到DOM最顶层结点的过程</p>
<p>4、基本数据类型</p>
<ul>
<li>基本数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></li>
<li>引用数据类型：<code>object</code>、<code>array</code>、<code>function</code></li>
</ul>
<p>JavaScript最新基本数据类型<code>BigInt</code>：<code>BigInt</code>数据类型是比 <code>Number</code>数据类型支持范围更大的整数值。</p>
<p>5、判断数组</p>
<ul>
<li><code>instanceof</code>方法：本质是判断原型</li>
<li><code>constructor</code>方法：返回对象相应的构造函数</li>
<li><code>Array.isArray()</code>方法</li>
</ul>
<p>6、0.1+0.2为什么不等于0.3</p>
<p>因为 <code>JS</code> 采用 <code>IEEE 754</code>双精度版本（<code>64</code>位），如下图。</p>
<img src="https://s1.ax1x.com/2020/08/07/afxB2n.jpg">

<p>在这种标准下，0.1和0.2转换为二进制后是无限循环的，JS采用的浮点数标准会裁剪掉无限循环的数字，从而导致精度丢失。</p>
<p>7、this</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>this指向</th>
</tr>
</thead>
<tbody><tr>
<td>普通函数</td>
<td>window</td>
</tr>
<tr>
<td>对象的方法</td>
<td>该方法所属对象</td>
</tr>
<tr>
<td>构造函数</td>
<td>实例对象，原型对象里的方法也指向实例对象</td>
</tr>
<tr>
<td>绑定事件函数</td>
<td>绑定事件对象</td>
</tr>
<tr>
<td>定时器函数</td>
<td>window</td>
</tr>
<tr>
<td>立即执行函数</td>
<td>window</td>
</tr>
</tbody></table>
<p>严格模式下全局作用域里函数中的<code>this</code>为<code>undefined</code>。</p>
<p>改变<code>this</code>指向的方法：<code>call()</code>、<code>bind()</code>、<code>apply()</code></p>
<p>8、new操作符过程</p>
<ul>
<li>创建一个空对象，并且 <code>this</code> 指向该对象，同时继承该函数的原型</li>
<li>将属性和方法加入到 <code>this</code> 引用的对象中</li>
<li>最后返回这个对象</li>
</ul>
<p>9、构造函数有返回值，new之后返回的是什么</p>
<p>如果构造函数<code>return</code>了一个新的“对象”，那么这个对象就会取代整个new出来的结果。</p>
<p>10、构造函数可不可以写成箭头函数</p>
<p>不可以，因为箭头函数没有<code>prototype</code>属性</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>1、sessionStorage</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
</tr>
<tr>
<td>数据存储大小</td>
<td><code>4K</code></td>
<td><code>5M</code></td>
<td><code>5M</code></td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在 header 中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody></table>
<p>2、生命周期</p>
<p> Vue 实例从创建到销毁的过程就是生命周期。是开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁的一系列过程。</p>
<p>总共分为8个阶段创建前后，载入前后，更新前后，销毁前后</p>
<p>3、data为什么是函数</p>
<p>每个组件都是Vue的实例，data如果是一个引用类型时，不同组件之间会相互影响。</p>
<p>4、Vue是双向数据流还是单向数据流</p>
<p>Vue是单向数据流，即数据总是由父组件传递到子组件，子组件在其内部可以有自己维护的数据，但它法直接修改父组件的数据。</p>
<p>5、data数据改变之后为什么页面不刷新</p>
<p>页面初始化时，vue会遍历data对象所有的属性，并使用<code>object.defineProperty</code>把这些属性全部转化为<code>getter/setter</code>。直接改变数组元素，或者在对象中添加属性可以改变数据，但不会更新视图。</p>
<p>需要适应响应式的方法触发视图更新，如：<code>Object.assign()</code>，<code>Vue.set()</code>，<code>Array.push()</code></p>
<p>6、优化</p>
<ul>
<li>不要在模板里面写过多表达式</li>
<li>循环调用子组件时添加key</li>
<li>频繁切换的使用v-show，不频繁切换的使用v-if</li>
<li>尽量少用float，可以用flex</li>
<li>按需加载，可以用<code>require</code>或者<code>import()</code>按需加载需要的组件</li>
<li>路由懒加载</li>
<li>通过 <code>addEventListener</code>添加的事件在组件销毁时要用 <code>removeEventListener</code> 手动移除这些事件的监听</li>
<li>对图片进行压缩</li>
<li>使用 <code>CommonsChunkPlugin</code> 插件提取公共代码</li>
<li>提取组件的 CSS</li>
</ul>
<p>7、虚拟DOM以及使用虚拟DOM的好处</p>
<p><code>Virtual DOM</code>本质就是用一个原生的<strong>JS对象</strong>去描述一个DOM节点。是对真实DOM的一层抽象。</p>
<p>使用原生JS或JQ操作DOM效率很低，并且会产生一定的性能问题。例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。</p>
<p>虚拟DOM目的是减少实际DOM操作，解决浏览器性能问题。</p>
<p>虚拟DOM流程：</p>
<ol>
<li>用JS模拟DOM树并渲染</li>
<li>比较新旧DOM树，得到比较的差异对象</li>
<li>把差异对象应用到渲染的DOM树</li>
</ol>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code中Vue语法不高亮显示</title>
    <url>/2020/08/06/VS-Code%E4%B8%ADVue%E8%AF%AD%E6%B3%95%E4%B8%8D%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>VS Code自动更新后，Vue语法失去高亮显示（如下图），其他文件都正常。</p>
<a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/08/06/agWOMV.png" alt=""></p>
<p>解决方法：重装vetur</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VS Code</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端布局01-流式布局</title>
    <url>/2020/07/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%8001-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="移动端基础"><a href="#移动端基础" class="headerlink" title="移动端基础"></a>移动端基础</h2><ul>
<li>移动端浏览器主要对webkit内核进行兼容</li>
<li>目前开发的移动端主要针对手机端开发</li>
<li>目前移动端碎片化比较严重，分辨率和屏幕尺寸大小不一</li>
<li>调试主要有三种方法<ul>
<li>使用Chrome DevTools（谷歌浏览器）的模拟手机调试</li>
<li>搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器</li>
<li>使用外网服务器，直接IP或域名访问</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>视口（viewport）就是浏览器显示页面内容的屏幕区域。分为布局视口、视觉视口和理想视口。</p>
<ol>
<li><p><strong>布局视口(layout viewport)</strong></p>
<p>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。<br>iOS, Android基本都将这个视口分辨率设置为 980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。</p>
</li>
<li><p><strong>视觉视口(visual viewport)</strong></p>
<p>是用户正在看到的网站的区域，用户可以通过缩放来操纵视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。</p>
</li>
<li><p><strong>理想视口(ideal viewport)</strong></p>
<p>理想视口对设备而言是最理想的视觉视口，是为了使网站在移动端有最理想的阅读宽度而设定的。需要手动添加<code>meta</code>标签告知浏览器。</p>
</li>
</ol>
<p><strong>meta标签</strong></p>
<p><code>meta</code>标签目的：使布局视口与理想视口宽度一致，即设备有多宽，布局视口就有多宽。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>width</code>: 指<code>viewport</code>，可以设置特殊值<code>device-width</code>。</li>
<li><code>user-scalable</code>: 用户是否可以缩放，值为yes 或 no （1或0）。</li>
<li><code>initial-scale</code>: 初始缩放比，要求为大于0的数字。</li>
<li><code>maximum-scale</code>: 最大缩放比，要求为大于0的数字。</li>
<li><code>minimum-scale</code>: 最小缩放比，要求为大于0的数字。</li>
</ul>
<p><strong>标准</strong>的viewport设置：</p>
<ul>
<li>视口宽度和设备保持一致</li>
<li>视口的默认缩放比例1.0</li>
<li>不允许用户自行缩放</li>
<li>最大允许的缩放比例1.0</li>
<li>最小允许的缩放比例1.0</li>
</ul>
<h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><p><strong>物理像素和物理像素比</strong></p>
<p><strong>物理像素</strong>：指屏幕显示的最小颗粒，是物理真实存在的，在手机出厂时就设置好了。在PC端页面，1px就等于1个物理像素，但是移动端并非如此。</p>
<p><strong>物理像素比</strong>：指1px能显示的物理像素点的个数，也成屏幕像素比。</p>
<blockquote>
<p>PC端和早期的手机屏幕以及普通手机屏幕: 1CSS像素 = 1 物理像素</p>
<p>Retina（视网膜屏幕）技术出现后，可以将更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。</p>
</blockquote>
<p><strong>多倍图</strong></p>
<p>对于一张 50px * 50px 的图片，在手机 Retina 屏中打开，按照2倍的物理像素比就会放大倍数，进而造成图片模糊。所以在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题。</p>
<p>通常使用二倍图， 部分还存在三倍图四倍图的情况，具体看实际开发需求。</p>
<p>解决方法：若要在移动端页面的到一张清晰的 50px*50px 的图片，可先准备一张 100px*100px 的图片并将其缩小至 50px*50px。</p>
<p><strong>背景缩放</strong></p>
<p><code>background-size</code> 属性规定背景图像的尺寸。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-size: 背景图片宽度 背景图片高度;</span><br></pre></td></tr></table></figure>

<p>参数： </p>
<ul>
<li>px: 规定具体宽高，只有一个参数即规定宽度，高度随宽度等比例缩放。</li>
<li>百分比: 百分比是对于父盒子而言的。</li>
<li><code>cover</code>: 等比例拉伸，背景图片完全覆盖父盒子，可能会导致图片显示不全。</li>
<li><code>contain</code>: 等比例拉伸，宽高有一边铺满父盒子时就不再拉伸，可能会导致盒子有空白区域。</li>
</ul>
<p><strong>二倍精灵图</strong></p>
<ul>
<li>在ps中把精灵图等比例缩放为原来的一半</li>
<li>然后测量大小和坐标</li>
<li>注意代码里面<code>background-size</code>也要写为精灵图原来宽度的一半</li>
</ul>
<h2 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h2><ol>
<li><p>单独制作移动端页面（主流）</p>
<p>通常情况下，网址域名前面加 <strong>m(mobile)</strong> 可以打开移动端。通过判断设备，如果是移动设备打开，则跳到<strong>移动端页面</strong>。</p>
</li>
<li><p>响应式页面兼容移动端</p>
<p>通过判断屏幕宽度来改变样式，以适应不同终端。</p>
</li>
</ol>
<h2 id="移动端技术"><a href="#移动端技术" class="headerlink" title="移动端技术"></a>移动端技术</h2><p>移动端浏览器基本以webkit内核为主，因此只需考虑webkit兼容性问题，且可使用 H5 标签和 CSS3 样式。浏览器的私有前缀只需要考虑添加 webkit 即可。</p>
<p><strong>CSS初始化</strong>：</p>
<p>推荐使用<code>normalize.css</code>，<a href="https://github.com/necolas/normalize.css/" target="_blank" rel="noopener">官方网址</a></p>
<p>特点：</p>
<ul>
<li>保护了有价值的默认值</li>
<li>修复了浏览器的bug</li>
<li>模块化</li>
<li>拥有详细的文档</li>
</ul>
<p><strong>CSS3盒子模型</strong>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CSS3盒子模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="comment">/* 传统盒子模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>;</span><br></pre></td></tr></table></figure>

<p>传统盒子模型：盒子的宽度为width + border + padding </p>
<p>CSS3盒子模型：盒子的宽度为width </p>
<p>区别：</p>
<ul>
<li>移动端可以全部使用CSS3 盒子模型</li>
<li>PC端如果不考虑兼容性，选择 CSS3 盒子模型，否则就用传统模式。</li>
</ul>
<p><strong>特殊样式</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CSS3盒子模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="comment">/* 需要清除点击高亮 设置为transparent 完成透明 */</span> </span><br><span class="line"><span class="selector-tag">-webkit-tap-highlight-color</span>: <span class="selector-tag">transparent</span>;</span><br><span class="line"><span class="comment">/* 在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式 */</span> </span><br><span class="line"><span class="selector-tag">-webkit-appearance</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="comment">/* 禁用长按页面时的弹出菜单 */</span></span><br><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">a</span> &#123; <span class="attribute">-webkit-touch-callout</span>: none; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h2><p><strong>技术选型</strong></p>
<p>单独制作移动端页面：</p>
<ul>
<li>流式布局（百分比布局）</li>
<li>flex弹性布局（推荐）</li>
<li>less + rem + 媒体查询布局</li>
<li>混合布局</li>
</ul>
<p>响应式页面兼容移动端：</p>
<ul>
<li>媒体查询</li>
<li>Bootstarp</li>
</ul>
<h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><p>流式布局就是百分比布局，也称固定像素布局。将盒子的<strong>宽度</strong>设置成百分比，从而根据屏幕的宽度进行伸缩，不受固定像素的限制，内容向两侧填充。</p>
<p>为了保护内容，还可以规定最大值和最小值：<code>max-width</code>，<code>min-width</code>，<code>max-height</code>，<code>min-height</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>移动端布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记07-Axios</title>
    <url>/2020/07/23/Vue/Vue%E7%AC%94%E8%AE%B007-Axios/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Axios是一个基于promise的HTTP库，适用于浏览器和node.js。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>浏览器端发起XMLHttpRequests请求</li>
<li>node端发起http请求</li>
<li>支持Promise API</li>
<li>拦截请求和返回</li>
<li>转化请求和返回（数据）</li>
<li>取消请求</li>
<li>自动转化json数据</li>
<li>客户端支持抵御XSRF（跨站请求伪造）</li>
</ul>
<a id="more"></a>

<h2 id="使用和配置"><a href="#使用和配置" class="headerlink" title="使用和配置"></a>使用和配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install axios -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为指定url创建请求</span></span><br><span class="line">axios.get(<span class="string">'http://123.207.32.32:8000/home/data?type=pop&amp;page=1'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.get(<span class="string">'/http://123.207.32.32:8000/home/data'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      type: <span class="string">'pop'</span>,</span><br><span class="line">      page: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><p><code>axios(config)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  url: <span class="string">'http://123.207.32.32:8000/home/multidata'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">'http://123.207.32.32:8000/home/data'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    <span class="comment">// 参数拼接 type=pop&amp;page=1</span></span><br><span class="line">    type: <span class="string">'pop'</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="axios支持多种请求方式"><a href="#axios支持多种请求方式" class="headerlink" title="axios支持多种请求方式"></a>axios支持多种请求方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axios(config)</span><br><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[,config])</span><br><span class="line">axios.delete(url[,config])</span><br><span class="line">axios.head(url[,data[,config])</span><br><span class="line">axios.post(url[,data[,config])</span><br><span class="line">axios.put(url[,data[,config])</span><br><span class="line">axios.patch(url[,data[,config])</span><br></pre></td></tr></table></figure>

<h3 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h3><p><code>axios.all(iterable)</code>可以放入多个请求，返回的结果是一个数组。</p>
<p><code>axios.spread(callback)</code>：将数组<code>[res1, res2]</code>展开为res1, res2。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">'http://123.207.32.32:8000/home/multidata'</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">'http://123.207.32.32:8000/home/data'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">'pop'</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>在开发中一些参数是固定的，所以可以进行抽取，也可以利用axios的全局配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'http://123.207.32.32:8000'</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>常见配置选项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求地址</span></span><br><span class="line">url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求类型,默认是 get</span></span><br><span class="line">method: <span class="string">'get'</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动加在url前面，除非url是一个绝对 URL</span></span><br><span class="line">baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求前的数据处理</span></span><br><span class="line">transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;&#125;],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求后的数据处理</span></span><br><span class="line">transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;&#125;],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的请求头</span></span><br><span class="line">headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// URL参数, 查询对象(query), 针对get请求</span></span><br><span class="line">params: &#123;</span><br><span class="line">  ID: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//  params序列化函数</span></span><br><span class="line">paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// request body请求体, 针对post请求</span></span><br><span class="line">data: &#123;</span><br><span class="line">  key: <span class="string">'a'</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定请求超时的毫秒数</span></span><br><span class="line">timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示跨域请求时是否需要使用凭证(token), 默认为false</span></span><br><span class="line">withCredentials: <span class="literal">false</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义请求处理</span></span><br><span class="line">adapter: <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject, config</span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 身份验证信息</span></span><br><span class="line">auth: &#123;</span><br><span class="line">  username: <span class="string">'a'</span>,</span><br><span class="line">  password: <span class="string">'123'</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器响应的数据类型：json(默认)/blob/document/arraybuffer/text/steam</span></span><br><span class="line">responseType: <span class="string">'json'</span>,</span><br></pre></td></tr></table></figure>

<h2 id="实例和模块封装"><a href="#实例和模块封装" class="headerlink" title="实例和模块封装"></a>实例和模块封装</h2><h3 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h3><p>需要请求多种url时，可能会有不同的配置要求，通过<code>axios.create</code>创建实例满足不同的请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'http://123.207.32.32:8000'</span>,</span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line">instance(&#123;</span><br><span class="line">  url: <span class="string">'/home/multidata'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h3><p>给每个要请求数据的组件引入axios，一旦axios出现问题，需要逐个修改。所以封装一个模块，组件需要请求数据时，就使用此模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  network/request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'http://123.207.32.32:8000'</span>,</span><br><span class="line">    timeout: <span class="number">3000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 真实请求，返回的是Promise</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">'/home/multidata'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 请求成功, 处理操作</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 请求失败, 处理操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 响应成功, 处理操作</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 响应失败, 处理操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>请求拦截的作用：</p>
<ul>
<li>config中一些信息不符合服务器的需求。</li>
<li>发送网络请求时希望在界面上显示一个请求的图标。</li>
<li>一些网络请求(如登录)，必须携带一些特殊信息。</li>
</ul>
<p>响应拦截的作用：</p>
<ul>
<li>对请求的数据进行过滤。</li>
<li>根据错误码跳转到不同的提示页面。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记06-Vuex</title>
    <url>/2020/07/21/Vue/Vue%E7%AC%94%E8%AE%B006-Vuex/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Vuex是一个专为Vue.js应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式存储管理</strong>应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>可以简单的将其看成把多个组件共享的变量全部存储在一个对象里面。再将这个对象放在顶层的Vue实例中，让其他组件可以使用。</p>
<a id="more"></a>

<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="单界面状态管理"><a href="#单界面状态管理" class="headerlink" title="单界面状态管理"></a>单界面状态管理</h3><p><img src="https://s1.ax1x.com/2020/07/17/U6z6mT.md.png" style="zoom: 60%; margin-left: 0" 
/> </p>
<ul>
<li>State：状态（可理解为data中的属性）</li>
<li>View：视图层，可以针对State的变化，显示不同的信息。</li>
<li>Actions：主要是用户的各种操作：点击、输入等，会导致状态的改变。</li>
</ul>
<h3 id="多界面状态管理"><a href="#多界面状态管理" class="headerlink" title="多界面状态管理"></a>多界面状态管理</h3><p>多个组件共享状态，把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p>
<img src="https://s1.ax1x.com/2020/07/18/UcCLrt.png" style="zoom:95%;" />

<ol>
<li>组件可以直接通过Mutations改变State。</li>
<li>存在异步操作时，需要将异步操作在Action中完成，再提交到Mutations。</li>
<li>提交mutation是更改状态的唯一方法。</li>
<li>devtools是浏览器插件，可以记录对State的修改。</li>
</ol>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在store/index.js 文件中创建并导出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    decrement(state) &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;,</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在Vue实例中挂载：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store,   <span class="comment">// // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>在其他Vue组件中通过 <code>this.$store</code> 来获取状态对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 store.state 来获取状态对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$store.state.count) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 store.commit 方法触发状态变更</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'decrement'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过提交mutation的方式，而非直接改变store.state.count。因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</p>
</blockquote>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li>State</li>
<li>Getters</li>
<li>Mutation</li>
<li>Action</li>
<li>Module</li>
</ul>
<h3 id="State单一状态树"><a href="#State单一状态树" class="headerlink" title="State单一状态树"></a>State单一状态树</h3><p>Vuex使用<strong>单一状态树</strong>，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源SSOT (Single Source of Truth) 而存在。这也意味着，每个应用将仅仅包含一个 store 实例。</p>
<p>单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p>
<p>在组件中使用 (需要在根组件里“注入”)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.count</span><br></pre></td></tr></table></figure>

<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>有多个组件需要用到某属性时，Vuex允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p>Getter接受stat作为其第一个参数，也可以接受其他getter作为第二个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;,</span><br><span class="line">    doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在组件中访问：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过让getter返回一个函数，来实现给getter传参。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById(state) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$store.getters.getTodoById(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>更改Vuex的store中的状态的<strong>唯一方法是提交mutation</strong>。</p>
<p>mutation包括两部分： <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。</p>
<p>事件类型为字符串，而这个回调函数就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在组件中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">increament() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提交载荷</strong>，可以向 <code>store.commit</code> 中传入额外的参数，即mutation的载荷（payload）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>载荷也可以是一个对象，这样可以包含多个字段并且记录的mutation会更易读：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>提交风格</strong></p>
<p>提交mutation的另一种方式是直接使用包含 <code>type</code> 属性的对象，当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变（同上）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>响应规则</strong></p>
<p>想要实现响应式，需要与使用Vue一样遵守一些注意事项：</p>
<ul>
<li>最好提前在store中初始化好所有所需属性。</li>
<li>当需要在对象上添加新属性时，有两种方式<ul>
<li>使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code></li>
<li>以新对象替换老对象。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    info: &#123;</span><br><span class="line">      name: <span class="string">'lwt'</span>,</span><br><span class="line">      age: <span class="number">23</span>,</span><br><span class="line">      height: <span class="number">1.65</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 非响应式</span></span><br><span class="line">    state.info[<span class="string">'address'</span>] = <span class="string">'China'</span> </span><br><span class="line">    <span class="comment">// 响应式</span></span><br><span class="line">    Vue.set(state.info, <span class="string">'address'</span>, <span class="string">'China'</span>)</span><br><span class="line">	<span class="comment">// 非响应式</span></span><br><span class="line">    <span class="keyword">delete</span> state.info.height </span><br><span class="line">	<span class="comment">// 响应式</span></span><br><span class="line">    Vue.delete(state.info, <span class="string">'height'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>使用常量替代Mutation事件类型</strong></p>
<p>在store文件夹下新建<code>mutation-types.js</code>在其中定义我们的常量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UPDATE_INFO = <span class="string">'UPDATE_INFO'</span></span><br></pre></td></tr></table></figure>

<p>使用时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  store/index.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; UPDATE_INFO &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [UPDATE_INFO] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; UPDATE_INFO &#125; <span class="keyword">from</span> <span class="string">'./store/mutation-types'</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  updateInfo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(UPDATE_INFO)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步函数</strong></p>
<p>通常情况下, Vuex要求我们Mutation中的方法必须是同步方法。主要的原因是当我们使用devtools时，可以devtools可以帮助我们捕捉mutation的快照。但是如果是异步操作，那么devtools将不能很好的追踪这个操作什么时候会被完成。</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action类似于mutation，不同在于：</p>
<ul>
<li>Action提交的是mutation，而不是直接变更状态。</li>
<li>Action可以包含任意异步操作。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Action函数接受一个与store实例具有相同方法和属性的<strong>context对象</strong>，因此可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p>
<p><strong>分发 Action</strong></p>
<p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (context) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>, payload)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>.store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">   	  amount: <span class="number">10</span></span><br><span class="line">	&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>.store.dispatch(&#123;</span><br><span class="line">   	  type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  	  amount: <span class="number">10</span></span><br><span class="line">	&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组合Action (Promise)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addInfo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex允许我们将store分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<p>module<strong>局部状态</strong></p>
<ul>
<li>对于模块内部的mutation和getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</li>
<li>对于模块内部的action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>。</li>
<li>对于模块内部的getter，根节点状态会作为第三个参数暴露出来。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 state 对象是模块的局部状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 state 对象是模块的局部状态</span></span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="comment">// &#123; state, commit, rootState &#125;解构赋值</span></span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="comment">// 第二个参数gettters可以获取其他getters</span></span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：  虽然 doubleCount 和 increment 都是定义在模块内部的，但是在调用的时候，依然是通过this.$store来直接调用。</p>
</blockquote>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>对于大型应用，我们会希望把Vuex相关代码分割到模块中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... <span class="comment"># 抽取出API请求</span></span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          <span class="comment"># 我们组装模块并导出 store 的地方</span></span><br><span class="line">    ├── actions.js        <span class="comment"># 根级别的 action</span></span><br><span class="line">    ├── mutations.js      <span class="comment"># 根级别的 mutation</span></span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       <span class="comment"># 购物车模块</span></span><br><span class="line">        └── products.js   <span class="comment"># 产品模块</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记05-Vue Router</title>
    <url>/2020/07/19/Vue/Vue%E7%AC%94%E8%AE%B005-Vue-Router/</url>
    <content><![CDATA[<h2 id="路由介绍"><a href="#路由介绍" class="headerlink" title="路由介绍"></a>路由介绍</h2><p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p>
<p><strong>后端路由</strong>：页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好对应的HTML页面, 并且将页面返回给客户顿。</p>
<p><strong>前后端分离</strong>：后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中。</p>
<p><strong>SPA(单页面富应用)</strong>：前后端分离的基础上加了一层前端路由，整个网站只有一个html页面，改变URL时，页面不进行整体的刷新。</p>
<a id="more"></a>

<h3 id="URL的hash"><a href="#URL的hash" class="headerlink" title="URL的hash"></a>URL的hash</h3><p>URL的hash也就是锚点(#), 本质上是改变<code>window.location</code>的<code>href</code>属性。可以通过直接赋值<code>location.hash</code>来改变<code>href</code>， 但是页面不发生刷新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location.hash &#x3D; &#39;&#x2F;foo&#39;</span><br></pre></td></tr></table></figure>

<h3 id="HTML5的history"><a href="#HTML5的history" class="headerlink" title="HTML5的history"></a>HTML5的history</h3><p>history接口是HTML5新增的，它有五种模式改变URL而不刷新页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; history.pushState(data, title, targetURL);</span><br><span class="line">history.pushState(&#123;&#125;, &#39;&#39;, &#39;&#x2F;home&#39;)</span><br><span class="line">history.back()</span><br><span class="line">history.forward()</span><br><span class="line">&#x2F;&#x2F; history.replaceState(data, title, targetURL);</span><br><span class="line">history.replaceState()</span><br><span class="line">history.go()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>history.pushState</code>：多次push相当于入栈。</li>
<li><code>history.back()</code>：等价于 <code>history.go(-1)</code>。</li>
<li><code>history.forward()</code>：等价于 <code>history.go(1)</code>。</li>
<li><code>history.replaceState</code>：替换，无法前进和后退</li>
<li><code>history.go</code>：基于<code>history.pushState</code>，括号内正值前进，负值后退。</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>安装vue-router：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install vue<span class="literal">-router</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<p>配置：</p>
<ol>
<li>导入路由对象，调用<code>Vue.use()</code></li>
<li>创建路由实例，传入路由映射配置</li>
<li>在Vue实例中挂载路由实例</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入组件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由映射</span></span><br><span class="line"><span class="keyword">const</span> routes = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出router实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Vue实例中挂载</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>创建路由组件</li>
<li>配置组件和路径的映射关系</li>
<li>通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code>使用路由</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Home.vue 创建Home组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;主页&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;主页内容&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Home&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style  scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js 配置路由映射</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// 导入Home组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../components/Home.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装vue-router组件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置路由映射</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,  <span class="comment">// 路由地址</span></span><br><span class="line">    component: Home  <span class="comment">// 组件名</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// App.vue 使用路由</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>补充：<br><code>&lt;router-link&gt;</code>:  该标签是一个vue-router中已经内置的组件，最终会被渲染成一个<code>&lt;a&gt;</code>标签。<br><code>&lt;router-view&gt;</code>：该标签用于占位，会根据当前的路径，动态渲染出不同的组件。</p>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><h3 id="路由默认路径"><a href="#路由默认路径" class="headerlink" title="路由默认路径"></a>路由默认路径</h3><p>使用重定向让路径默认跳转到另一个路径。<br>如将根路径重定向到<code>/home</code>的路径下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,           <span class="comment">// path配置了根路径</span></span><br><span class="line">    redirect: <span class="string">'/home'</span>    <span class="comment">// 重定向</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="HTML5的History模式"><a href="#HTML5的History模式" class="headerlink" title="HTML5的History模式"></a>HTML5的History模式</h3><p>改变路径的方式有两种：URL的hash 和 HTML5的history。<br>默认情况下, 路径的改变使用的URL的hash。<br>修改为history模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">'history'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="router-link属性"><a href="#router-link属性" class="headerlink" title="router-link属性"></a>router-link属性</h3><ul>
<li><p><code>to</code>： 跳转到指定路径。</p>
</li>
<li><p><code>tag</code>： 指定<code>&lt;router-link&gt;</code>最后渲染成什么元素。</p>
</li>
<li><p><code>replace</code>： 不会留下history记录，即无法使用后退和前进</p>
</li>
<li><p><code>active-class</code>： 当<code>&lt;router-link&gt;</code>对应的路由匹配成功时，会自动给当前元素设置一个<code>router-link-active</code>的属性。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/home'</span> <span class="attr">tag</span>=<span class="string">'button'</span> <span class="attr">replace</span> <span class="attr">active-class</span>=<span class="string">'active'</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/about'</span> <span class="attr">tag</span>=<span class="string">'button'</span> <span class="attr">replace</span> <span class="attr">active-class</span>=<span class="string">'active'</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用linkActiveClass统一修改active-class类名</span></span><br><span class="line"><span class="comment">// router实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  linkActiveClass: <span class="string">'active'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="路由代码跳转"><a href="#路由代码跳转" class="headerlink" title="路由代码跳转"></a>路由代码跳转</h3><p>当页面跳转还需要执行对应js代码时，就需要使用代码跳转。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;homeBtn&quot;&gt;首页&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;aboutBtn&quot;&gt;关于&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    homeBtn() &#123;</span><br><span class="line">      &#x2F;&#x2F; push 对应 pushState</span><br><span class="line">      &#x2F;&#x2F; this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">      this.$router.replace(&#39;&#x2F;home&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    aboutBtn() &#123;</span><br><span class="line">      &#x2F;&#x2F; push 对应 pushState</span><br><span class="line">      &#x2F;&#x2F; this.$router.push(&#39;&#x2F;about&#39;)</span><br><span class="line">      this.$router.replace(&#39;&#x2F;about&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>一个页面的path路径可能是不确定的，如进入用户界面时，可以在路径后加上用户ID (/user/id)。这种path和Component的匹配关系就是动态路由。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 动态路径参数，以冒号开头</span></span><br><span class="line">    path: <span class="string">'/user/:userId'</span>,</span><br><span class="line">    component: User</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'/user/'+userId"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      userId: <span class="string">'lsy'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$route.params.userId&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>方法一： 结合Vue的异步组件和Webpack的代码分割功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="built_in">require</span>.ensure([<span class="string">'../components/Home.vue'</span>], () =&gt; &#123; resolve(<span class="built_in">require</span>(<span class="string">'../components/Home.vue'</span>)) &#125;)&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二： AMD写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'../components/About.vue'</span>], resolve);</span><br></pre></td></tr></table></figure>

<p>方法三： ES6中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Home.vue'</span>)</span><br></pre></td></tr></table></figure>

<p>未使用懒加载，打包后js文件如下：</p>
<p><img src="https://s1.ax1x.com/2020/07/17/UyfLLV.png" alt=""></p>
<p>使用懒加载后：</p>
<p><img src="https://s1.ax1x.com/2020/07/17/UyhRp9.png" alt=""></p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><ol>
<li>创建对应的子组件, 并且在路由映射中配置对应的子路由.</li>
<li>在组件内部使用<code>&lt;router-link&gt;</code> 和 <code>&lt;router-view&gt;</code>标签.</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/07/17/Uy4m7T.png" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// idnex.js</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  component: Home,</span><br><span class="line">  <span class="comment">// 嵌套</span></span><br><span class="line">  children: [    </span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,         <span class="comment">// 重定向</span></span><br><span class="line">      redirect: <span class="string">'news'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'news'</span>,</span><br><span class="line">      component: News</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      path: <span class="string">'message'</span>, </span><br><span class="line">      component: Message </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>传递参数主要有两种类型: params 和 query。<br>每种类型都有<code>&lt;router-link&gt;</code>的和JavaScript代码两种方式。</p>
<h3 id="params类型"><a href="#params类型" class="headerlink" title="params类型"></a>params类型</h3><ul>
<li>配置路由格式： /router/:id</li>
<li>传递的方式： 在path后面跟上对应的值</li>
<li>传递后形成的路径： /router/123， /router/abc</li>
</ul>
<p><code>&lt;router-link&gt;</code>方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'/user/'+userId"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript代码方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  userBtn() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/user/'</span> + <span class="keyword">this</span>.userId)</span><br><span class="line">    <span class="comment">// 对于命名路由</span></span><br><span class="line">    <span class="keyword">this</span>.$router.push(&#123; </span><br><span class="line">      name: <span class="string">'user'</span>, </span><br><span class="line">      params: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="query类型"><a href="#query类型" class="headerlink" title="query类型"></a>query类型</h3><p>传递后形成的路径： /router?id=123</p>
<p><code>&lt;router-link&gt;</code>方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;path: '/profile', query: &#123;name: 'lsy',age: 18, height: 1.66&#125;&#125;"</span>&gt;</span>简介<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript代码方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  profileBtn() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">      path: <span class="string">'profile'</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        name: <span class="string">'lsy'</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        order: <span class="number">1.66</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p>
</blockquote>
<p><a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">参考文档</a></p>
<h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><p>通过<code>$route</code>对象获取参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$route.params.userId&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item of $route.query"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">     &#123;&#123; item &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="route和-router"><a href="#route和-router" class="headerlink" title="$route和$router"></a>$route和$router</h3><ul>
<li><code>$router</code>为VueRouter实例，想要导航到不同URL，则使用<code>$router.push</code>方法</li>
<li><code>$route</code>为当前router跳转对象 (活跃对象)，可以获取name、path、query、params等 </li>
</ul>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p><code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航，即监听路由的进入和离开。有全局的、单个路由独享的、组件级的。</p>
<h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>全局守卫有<code>beforeEach</code> 和 <code>afterEach</code>的钩子函数，它们会在路由改变前和改变后触发。</p>
<p><strong>全局前置守卫</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">                              </span><br><span class="line"><span class="comment">// 使用router.beforeEach注册一个全局前置守卫</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>to: Route</code>: 即将要进入的目标 <a href="https://router.vuejs.org/zh/api/#路由对象" target="_blank" rel="noopener">路由对象</a></li>
<li><code>from: Route</code>: 当前导航正要离开的路由</li>
<li><code>next: Function</code>: 一定要调用次方法。执行效果依赖 <code>next</code> 方法的调用参数。<ul>
<li><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li>
<li><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li><code>next(&#39;/&#39;)</code> 或者 <code>next({ path: &#39;/&#39; })</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象。</li>
</ul>
</li>
</ul>
<p><strong>全局后置钩子</strong>：</p>
<p>和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="[https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局前置守卫)">导航守卫参考</a></p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p>
<p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;keep-alive&gt;</code>属性：</p>
<ul>
<li>include： 字符串或正则表达，只有匹配的组件会被缓存。</li>
<li>exclude： 字符串或正则表达式，任何匹配的组件都不会被缓存。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以直接使用组件的name属性，多个值用逗号隔开，不能加空格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">'Profile,User'</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记04-CLI</title>
    <url>/2020/07/19/Vue/Vue%E7%AC%94%E8%AE%B004-CLI/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CLI (Command-Line Interface)命令行界面,，俗称<strong>脚手架</strong>。使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置。</p>
<p>Vue CLI 基于Node和Webpack。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v12.14.1</span><br><span class="line">$ webpack -v</span><br><span class="line">3.6.0</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> @vue/cli</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure>

<p>查看版本：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vue -<span class="literal">-version</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>拉取 2.x 模板 (旧版本)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="comment"># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>

<p>初始化项目</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Vue CLI2初始化项目</span></span><br><span class="line">vue init webpack my<span class="literal">-project</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Vue CLI3/4初始化项目</span></span><br><span class="line">vue create my<span class="literal">-project</span></span><br></pre></td></tr></table></figure>

<h3 id="Runtime-Compiler和Runtime-only"><a href="#Runtime-Compiler和Runtime-only" class="headerlink" title="Runtime-Compiler和Runtime-only"></a>Runtime-Compiler和Runtime-only</h3><p>Vue程序运行过程：</p>
<p><img src="https://s1.ax1x.com/2020/07/16/UrpzQK.png" alt=""></p>
<ul>
<li>Runtime-Compiler ： template -&gt; ast (抽象语法树) -&gt; render -&gt; virtual dom -&gt; 真实DOM</li>
<li>Runtime-only ： render -&gt; virtual dom -&gt; 真实DOM</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runtime-Compiler </span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    components: &#123; App &#125;,</span><br><span class="line">    template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime-only</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="render函数的使用"><a href="#render函数的使用" class="headerlink" title="render函数的使用"></a>render函数的使用</h3><p>该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>(虚拟节点)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render: (<span class="function"><span class="params">createElement</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 方法一：return createElement('标签', &#123;标签的属性&#125;, ['内容'])</span></span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'h2'</span>,</span><br><span class="line">            	 	&#123;<span class="attr">class</span>: <span class="string">'box'</span>&#125;,</span><br><span class="line">             		[<span class="string">'Hello World'</span>, createElement(<span class="string">'button'</span>, [<span class="string">'按钮'</span>])])</span><br><span class="line">    <span class="comment">// 2. 方法二：传入组件对象</span></span><br><span class="line">	<span class="keyword">return</span> createElement(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="CLI3"><a href="#CLI3" class="headerlink" title="CLI3"></a>CLI3</h2><ul>
<li>vue-cli 3是基于webpack 4打造，vue-cli 2 还是webapck 3</li>
<li>vue-cli 3的设计原则是“0配置”，移除的配置文件根目录下的，build和config等目录</li>
<li>vue-cli 3提供了 vue ui 命令提供了可视化配置，更加人性化</li>
<li>移除了static文件夹，新增了public文件夹，并且index.html移动到public中</li>
</ul>
<p>查看配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo发布成功博客不显示</title>
    <url>/2020/07/17/Hexo%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>问题描述：</p>
<p><code>hexo s</code>在本地服务器上可以查看到新发布的文章，<code>hexo d</code>发布成功无报错信息。但是在博客上无法显示新发布的文章。</p>
<p>尝试删除blog文件夹下的<code>.deploy_git</code> 并重新部署，依旧无法显示。</p>
<p>最后发现是github登录邮箱设置成了<code>private</code>，所以更新的内容无法通过<code>hexo d</code>发布到github。</p>
<a id="more"></a>

<p>解决方法：</p>
<p>打开github设置，setting =&gt; email =&gt; 取消勾选<code>Keep my email addresses private</code></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记03-Webpack</title>
    <url>/2020/07/17/Vue/Vue%E7%AC%94%E8%AE%B003-Webpack/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>从本质上来讲，webpack是一个现代的JavaScript应用的静态<strong>模块打包</strong>工具。</p>
<p>webpack其中一个核心就是让我们能进行<strong>模块化</strong>开发，并且会帮助我们处理模块间的依赖关系。不仅仅是JavaScript文件，CSS、图片、json文件等等在webpack中都可以被当做模块来使用。</p>
<a id="more"></a>

<p><strong>打包</strong>就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。并且在打包的过程中，还可以对资源进行处理，如压缩图片，scss转成css，ES6语法转成ES5语法，TypeScript转成JavaScript等等操作。</p>
<h3 id="与grunt-gulp对比"><a href="#与grunt-gulp对比" class="headerlink" title="与grunt/gulp对比"></a>与grunt/gulp对比</h3><p>grunt/gulp可以配置一系列的task，并且定义task要处理的事务 (如ES6、ts转化，图片压缩，scss转成css)。之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。所以grunt/gulp也被称为前端自动化任务管理工具。</p>
<p>区别：</p>
<ul>
<li>grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。</li>
<li>webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm。</p>
<p>查看node版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v12.14.1</span><br></pre></td></tr></table></figure>

<p>全局安装webpack(此处指定版本号3.6.0)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack@3.6.0 -g</span><br></pre></td></tr></table></figure>

<p>局部安装webpack(<code>--save-dev</code>是开发时依赖，项目打包后不需要继续使用)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入对应目录</span><br><span class="line">npm install webpack@3.6.0 --save-dev</span><br></pre></td></tr></table></figure>

<p>全局安装后再局部安装的原因：<br>在终端直接执行webpack命令，使用的全局安装的webpack，当在<code>package.json</code>文件中定义scripts，其中包含webpack命令时，那么使用的是局部webpack。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3><p>创建<code>webpack.config.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口：可以是字符串/数组/对象</span></span><br><span class="line">    entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">    <span class="comment">// 出口：通常是一个对象,至少包含两个属性，path,filename</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>局部安装webpack后使用命令打包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node_modules&#x2F;.bin&#x2F;webpack</span><br></pre></td></tr></table></figure>

<h3 id="package-json中定义启动"><a href="#package-json中定义启动" class="headerlink" title="package.json中定义启动"></a>package.json中定义启动</h3><p>再<code>package.json</code>文件的scripts中定义自己的执行脚本。scripts会寻找本地的node_modules/.bin路径中对应的命令，如果没有找到，就会去全局的环境变量中寻找。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用build打包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure>

<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>loader让webpack能够去处理那些非JavaScript文件（webpack 自身只理解 JavaScript）。oader可以将所有类型的文件转换为webpack能够处理的有效模块，如加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。然后就可以利用webpack的打包能力，对它们进行处理。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>通过npm安装需要使用的loader</li>
<li>在<code>webpack.config.js</code>中的modules关键字下进行配置</li>
</ul>
<p>参考资料：</p>
<p><a href="https://vue-loader.vuejs.org/zh/" target="_blank" rel="noopener">Vue Loader</a></p>
<p><a href="https://www.webpackjs.com/loaders/" target="_blank" rel="noopener">Loader文档</a></p>
<h2 id="配置Vue"><a href="#配置Vue" class="headerlink" title="配置Vue"></a>配置Vue</h2><h3 id="引入vue-js"><a href="#引入vue-js" class="headerlink" title="引入vue.js"></a>引入vue.js</h3><p>注意不是开发时依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install vue --save</span><br></pre></td></tr></table></figure>

<h3 id="el和template"><a href="#el和template" class="headerlink" title="el和template"></a>el和template</h3><ul>
<li>el用于指定Vue要管理的DOM，可以帮助解析其中的指令、事件监听等。</li>
<li>如果Vue实例中同时指定了template，那么template模板的内容会替换掉挂载的对应el的模板。</li>
</ul>
<p>之后就不需要再操作index.html，只需要在template中写入对应的标签即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">    template: <span class="string">`&lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;`</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'App组件'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="vue文件封装处理"><a href="#vue文件封装处理" class="headerlink" title=".vue文件封装处理"></a><code>.vue</code>文件封装处理</h3><p>一个组件以一个js对象的形式进行组织和使用非常麻烦，编写template模块也很不方便。所以使用<code>.vue</code>文件组织一个vue组件。</p>
<p>加载<code>.vue</code>文件需先安装vue-loader和vue-template-compiler：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>

<p>修改<code>webpack.config.js</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ... 其它规则</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 请确保引入这个插件！</span></span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="[https://vue-loader.vuejs.org/zh/guide/#%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AE](https://vue-loader.vuejs.org/zh/guide/#手动设置)">Vue Loader设置</a></p>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等。</p>
<p>loader和plugin区别：</p>
<ul>
<li>loader主要用于转换某些类型的模块，它是一个转换器。</li>
<li>plugin是插件，它是对webpack本身的扩展，是一个扩展器。</li>
</ul>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul>
<li>通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)。</li>
<li>在<code>webpack.config.js</code>文件里的plugins选项中配置插件。</li>
</ul>
<h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>使用<code>HtmlWebpackPlugin</code>将<code>index.html</code>文件打包到dist文件夹中。</p>
<p><code>HtmlWebpackPlugin</code>会自动生成一个<code>index.html</code>文件(可以指定模板生成)。将打包的js文件自动通过script标签插入到body中。</p>
<p>安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>修改<code>webpack.config.js</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ... 其它规则 </span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="comment">// 指定模板</span></span><br><span class="line">        template: <span class="string">'index.html'</span></span><br><span class="line">      &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UglifyjsWebpackPlugin"><a href="#UglifyjsWebpackPlugin" class="headerlink" title="UglifyjsWebpackPlugin"></a>UglifyjsWebpackPlugin</h3><p><code>UglifyjsWebpackPlugin</code>对打包的js文件进行压缩</p>
<p>安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</span><br></pre></td></tr></table></figure>

<p>修改<code>webpack.config.js</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ... 其它规则 </span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyjsWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h2><p>webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，可以实现浏览器自动刷新的效果。</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev webpack-dev-server@2.9.1</span><br></pre></td></tr></table></figure>

<p>修改<code>webpack.config.js</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ... 其它规则 </span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">      contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">      inline: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>contentBase：为哪一个文件夹提供本地服务，默认是根文件夹</li>
<li>port：端口号</li>
<li>inline：页面实时刷新</li>
<li>historyApiFallback：在SPA页面中，依赖HTML5的history模式</li>
</ul>
<p>修改<code>package.json</code>文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "dev": "webpack-dev-server --open"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>--open</code>参数表示直接打开浏览器。</p>
<h2 id="配置分离"><a href="#配置分离" class="headerlink" title="配置分离"></a>配置分离</h2><p>在不同环境中可能需要不同的配置，创建三个配置文件:</p>
<ul>
<li><code>base.config.js</code>: 开发环境和生产环境都必须的配置</li>
<li><code>dev.config.js</code>: 开发环境需要的配置</li>
<li><code>prod.config.js</code>: 生产环境需要的配置</li>
</ul>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install webpack-merge --save-dev</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./base.config'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, &#123;</span><br><span class="line">  <span class="comment">// 开发环境配置或生产环境配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记02-组件化与模块化开发</title>
    <url>/2020/07/16/Vue/Vue%E7%AC%94%E8%AE%B002-%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="组件化思想"><a href="#组件化思想" class="headerlink" title="组件化思想"></a>组件化思想</h2><p>提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。任何的应用都会被抽象成一颗组件树。</p>
<p><img src="https://s1.ax1x.com/2020/07/15/UdFrQS.png" alt=""></p>
<a id="more"></a>

<h2 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h2><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol>
<li><p>创建组件构造器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用Vue.extend()创建组件构造器,传入template代表自定义组件的模板</span></span><br><span class="line"><span class="keyword">const</span> myComponent = Vue.extend(&#123;</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;组件标题&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;组件内容，124356&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>注册组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用Vue.component()将刚才的组件构造器注册为一个组件</span></span><br><span class="line"><span class="comment">// 参数(注册组件的标签名, 组件构造器)</span></span><br><span class="line">Vue.component(<span class="string">'my-cpn'</span>, myComponent)</span><br></pre></td></tr></table></figure></li>
<li><p>使用组件<br>组件名使用短横线分隔命名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h3><p>通过调用<code>Vue.component()</code>注册组件时，组件的注册是全局的，即该组件可以在任意Vue示例下使用。</p>
<p>如果注册的组件是挂载在某个实例中, 那么就是一个局部组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">'你好'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn: myComponent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.语法糖方式注册全局组件</span></span><br><span class="line">Vue.component(<span class="string">'myComponent'</span>, &#123;</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;这是标题1&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;这是内容，哈哈哈哈哈&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.语法糖方式注册局部组件</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        myComponent: &#123;</span><br><span class="line">            template: <span class="string">`</span></span><br><span class="line"><span class="string">                &lt;div&gt;局部组件&lt;/div&gt;</span></span><br><span class="line"><span class="string">                `</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="分离模板"><a href="#分离模板" class="headerlink" title="分离模板"></a>分离模板</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.script标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-handlebars"</span> <span class="attr">id</span>=<span class="string">"cpn"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>组件标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>组件内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.template标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>组件标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>组件内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn: &#123;</span><br><span class="line">            template: <span class="string">'#cpn'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="组件数据"><a href="#组件数据" class="headerlink" title="组件数据"></a>组件数据</h3><p>组件对象也有一个data属性(也有methods等)。data属性必须是一个函数，返回一个对象，对象内部保存着数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'cpn'</span>,&#123;</span><br><span class="line">    template: <span class="string">'#cpn'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            title: <span class="string">'组件标题'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p><img src="https://s1.ax1x.com/2020/07/15/UdUKuF.png" alt=""></p>
<ul>
<li>父组件通过props向子组件传递数据</li>
<li>子组件通过事件向父组件发送消息</li>
</ul>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>在组件中，使用选项props来声明子组件需要从父组件接收到的数据。在HTML中使用时，需要将驼峰命名法的 prop 转换为其等价的短横线分隔命名。</p>
<p>props的值有<strong>字符串数组</strong>和<strong>对象</strong>两种方式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 字符串数组</span></span><br><span class="line">props: [<span class="string">'title'</span>, <span class="string">'likes'</span>, <span class="string">'isPublished'</span>, <span class="string">'author'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 对象 (名称：类型)</span></span><br><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>props验证</strong>: 可以为组件的 props 指定验证要求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>子组件使用自定义事件向父组件传递数据。</p>
<p>事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p>
<p>流程：</p>
<ul>
<li>在子组件中，通过$emit()来触发事件。</li>
<li>在父组件中，通过v-on来监听子组件事件。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> @<span class="attr">item-click</span>=<span class="string">"cpnClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">"item in categories"</span> @<span class="attr">click</span>=<span class="string">"btnClick(item)"</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">    template: <span class="string">'#cpn'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            categories: [</span><br><span class="line">                &#123;<span class="attr">id</span> :<span class="number">1</span>, <span class="attr">name</span>:<span class="string">'热门推荐'</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span> :<span class="number">2</span>, <span class="attr">name</span>:<span class="string">'手机数码'</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span> :<span class="number">3</span>, <span class="attr">name</span>:<span class="string">'家用家电'</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span> :<span class="number">4</span>, <span class="attr">name</span>:<span class="string">'电脑办公'</span>&#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        btnClick(item) &#123;</span><br><span class="line">            <span class="comment">//发射</span></span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'item-click'</span>, item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        cpnClick(item) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'cpnClick'</span>, item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="组件访问"><a href="#组件访问" class="headerlink" title="组件访问"></a>组件访问</h3><ul>
<li>父组件访问子组件：使用<code>$children</code>或<code>$refs</code></li>
<li>子组件访问父组件：使用<code>$parent</code></li>
</ul>
<ol>
<li><p><code>$children</code>(较少使用)<br><code>this.$children</code>返回数组类型，它包含所有子组件对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$children[<span class="number">0</span>].name);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> <span class="keyword">this</span>.$children) &#123;</span><br><span class="line">    i.showMessage();</span><br><span class="line">    <span class="built_in">console</span>.log(i.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$refs</code>(推荐)<br><code>$refs</code>和<code>ref</code>指令通常是一起使用的。先通过<code>ref</code>给某一个子组件绑定一个特定的ID，再通过<code>this.$refs.ID</code>访问该组件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn1</span> <span class="attr">ref</span>=<span class="string">"child1"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cpn2</span> <span class="attr">ref</span>=<span class="string">"child2"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"showRefsCpn"</span>&gt;</span>通过refs访问子组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showRefsCpn() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child1.message);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child2.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$parent</code>(较少使用)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showParent() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$.root</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问根组件root</span></span><br><span class="line">showRoot() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$root)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.$root.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>在子组件中，使用特殊的元素<code>slot</code>就可以为子组件开启一个插槽。该插槽插入什么内容取决于父组件如何使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>我是i元素<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 多个值同时放入组件中进行替换，将一起作为替换元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>222<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>333<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容，哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><ul>
<li>给<code>slot</code>元素一个<code>name</code>属性</li>
<li>在 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-slot:</span> <span class="attr">center</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-slot:</span> <span class="attr">left</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 缩写(只在其有参数时才可用) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> #<span class="attr">left</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cpn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p><strong>编译作用域</strong>：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</p>
<p>作用域插槽的使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用带值的v-slot来定义我们提供的插槽prop的名字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 不带参数的 v-slot 被假定对应默认插槽 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 解构插槽prop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- user重命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user: person &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; person.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>  <span class="attr">id</span>=<span class="string">"current-user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 绑定在slot元素上的attribute被称为插槽prop --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2><p>常见的模块化规范：CommonJS、AMD、CMD、ES6的Modules</p>
<h2 id="CommonJS（了解）"><a href="#CommonJS（了解）" class="headerlink" title="CommonJS（了解）"></a>CommonJS（了解）</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    flag: <span class="literal">true</span>,</span><br><span class="line">    sum(num1, num2) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;flag, sum&#125; = <span class="built_in">require</span>(<span class="string">'module'</span>)</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">let</span> _mod = <span class="built_in">require</span>(<span class="string">'module'</span>);</span><br><span class="line"><span class="keyword">let</span> flag = _mod.flag;</span><br><span class="line"><span class="keyword">let</span> sum = _mod.sum;</span><br></pre></td></tr></table></figure>

<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h3><p>使用<code>export</code>指令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    flag, count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出方法或类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mull</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    run() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'在奔跑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default(导入者可以自己命名)</span></span><br><span class="line"><span class="comment">// const address = '北京市'</span></span><br><span class="line"><span class="comment">// export default address</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">argument</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： export default在同一个模块中，不允许同时存在多个。</p>
</blockquote>
<h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><p>需要在HTML代码中引入js文件，并设置module类型</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"info.js"</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>import</code>指令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接导入变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;flag, count&#125; <span class="keyword">from</span> <span class="string">"./aaa.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入方法或类</span></span><br><span class="line"><span class="keyword">import</span> &#123;mull, Person&#125; <span class="keyword">from</span> <span class="string">"./aaa.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入default</span></span><br><span class="line"><span class="keyword">import</span> addr <span class="keyword">from</span> <span class="string">'./aaa.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部导入(通常情况下需要给*起一个别名)</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> aaa <span class="keyword">from</span> <span class="string">'./aaa.js'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记01-基础知识</title>
    <url>/2020/07/15/Vue/Vue%E7%AC%94%E8%AE%B001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue是一个<strong>渐进式</strong>的框架，即可以将Vue作为应用的一部分嵌入其中。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>方法一：直接CDN引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.11"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>方法二：下载和引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开发环境 https:&#x2F;&#x2F;vuejs.org&#x2F;js&#x2F;vue.js </span><br><span class="line">生产环境 https:&#x2F;&#x2F;vuejs.org&#x2F;js&#x2F;vue.min.js</span><br></pre></td></tr></table></figure>

<p>方法三：NPM安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 最新稳定版</span><br><span class="line">$ npm install vue</span><br></pre></td></tr></table></figure>

<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://s1.ax1x.com/2020/07/14/UUozZj.png" alt=""></p>
<ol>
<li><p>View层(视图层)</p>
<ul>
<li>在前端开发中，通常就是DOM层</li>
<li>主要的作用是给用户展示各种信息</li>
</ul>
</li>
<li><p>Model层(模型层)</p>
<p>数据可能是固定写好的死数据，单更多的是来自服务器，从网络上请求下来的数据。</p>
</li>
<li><p>ViewModel(视图模型层)</p>
<ul>
<li>视图模型层是View和Model沟通的桥梁</li>
<li>一方面它实现了数据绑定，将Model的改变实时的反映到View中</li>
<li>另一方面它实现了DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data</li>
</ul>
</li>
</ol>
<h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><h3 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h3><ol>
<li><p>el</p>
<ul>
<li>类型：<code>string</code> | <code>Element</code></li>
<li>要求：只在用 <code>new</code> 创建实例时生效。</li>
<li>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</li>
</ul>
</li>
<li><p>data</p>
<ul>
<li>类型：<code>Object</code> | <code>Function</code></li>
<li>要求：组件的定义只接受 <code>function</code>。</li>
<li>Vue 实例的数据对象。</li>
</ul>
</li>
<li><p>computed</p>
<ul>
<li>类型：<code>{ [key: string]: Function | { get: Function, set: Function } }</code></li>
<li>所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。(箭头函数this不会指向这个组件的实例)</li>
</ul>
</li>
<li><p>methods</p>
<ul>
<li>类型：<code>{ [key: string]: Function }</code></li>
<li>可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。(箭头函数this不会指向这个组件的实例)</li>
</ul>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>从vue实例创建,运行到销毁期间,总是伴随着各种各样的事件,这些事件统称为生命周期。</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UaQPNF.png" alt=""></p>
<ul>
<li>beforeCreate: 实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</li>
<li>created: 在实例创建完成后被立即调用，此时，挂载阶段还没开始。</li>
<li>beforeMount: 此时已经完成模板的编译,但是还没有挂载到页面中。</li>
<li>mounted: 实例被挂载后调用。</li>
<li>beforeUpdate: 数据更新之前调用，此时还没有开始渲染DOM节点，所以data值已经被修改，但是页面上显示的数据还是未修改的值。</li>
<li>updated: 组件 DOM 更新完毕之后调用，此时页面上显示的数据也完成了更新。</li>
<li>beforeDestory: 实例销毁之前调用，在这一步,实例仍然完全可用。</li>
<li>destoryed: 实例销毁后调用，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</li>
</ul>
<h2 id="插值操作"><a href="#插值操作" class="headerlink" title="插值操作"></a>插值操作</h2><h3 id="Mustache"><a href="#Mustache" class="headerlink" title="Mustache"></a>Mustache</h3><p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mustache语法中，不仅可以直接写变量，还可以写简单的表达式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstname + ' ' + lastname&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstname&#125;&#125; &#123;&#123;lastname&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;counter * 2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ol>
<li>该指令后面不需要跟任何表达式。</li>
<li>该指令表示元素和组件只渲染一次，不会随着数据的改变而改变。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-text和v-html"><a href="#v-text和v-html" class="headerlink" title="v-text和v-html"></a>v-text和v-html</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span>，被覆盖<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-html</span>=<span class="string">"url"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通常情况下，都会接收一个string类型。</p>
<blockquote>
<p>区别：</p>
<p>1.v-html会解析HTML格式，并且显示对应的内容。</p>
<p>2.v-text作用与Mustache一致，不会解析HTML。</p>
<p>3.v-text会把后面的文本覆盖掉。</p>
</blockquote>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示的是&#123;&#123;message&#125;&#125;--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>在某些情况下，浏览器可能会直接显然出未编译的Mustache标签，v-cloak可以在内容正常加载出之前隐藏元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                message: <span class="string">'你好'</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[v-cloak]</span>&#123;</span><br><span class="line">            <span class="attribute">display</span>: none;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h2><h3 id="v-bind基础"><a href="#v-bind基础" class="headerlink" title="v-bind基础"></a>v-bind基础</h3><p>v-bind可以绑定一个或多个属性值，用于响应式地更新 HTML属性，或者向另一个组件传递props值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"href"</span>&gt;</span>Vue.js官网<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--语法糖的写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"href"</span>&gt;</span>Vue.js官网<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="绑定Class"><a href="#绑定Class" class="headerlink" title="绑定Class"></a>绑定Class</h3><p>绑定Class有对象语法和数组语法两种方式。</p>
<ol>
<li><p>对象语法：class后面跟的是一个对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用法一：直接通过&#123;&#125;绑定一个类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">"&#123;'active': isActive&#125;"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用法二：可以通过判断，传入多个值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">"&#123;'active': isActive, 'line': isLine&#125;"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用法三：和普通的类同时存在，并不冲突 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果isActive和isLine都为true，那么会有title/active/line三个类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title"</span> <span class="attr">:class</span>=<span class="string">"&#123;'active': isActive, 'line': isLine&#125;"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用法四：如果过于复杂，可以放在一个methods或者computed中 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- classes是一个计算属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title"</span> <span class="attr">:class</span>=<span class="string">"classes"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组语法：class后面跟的是一个数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用法一：直接通过[]绑定一个类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">"['active']"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用法二：可以传入多个值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">"['active', 'line']"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用法三：和普通的类同时存在，并不冲突 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会有title/active/line三个类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title"</span> <span class="attr">:class</span>=<span class="string">"['active', 'line']"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用法四：如果过于复杂，可以放在一个methods或者computed中 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- classes是一个计算属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title"</span> <span class="attr">:class</span>=<span class="string">"classes"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="绑定Style"><a href="#绑定Style" class="headerlink" title="绑定Style"></a>绑定Style</h3><p>绑定Style有对象语法和数组语法两种方式。</p>
<ol>
<li><p>对象语法：style后面跟的是一个对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS属性名注意使用驼峰式命名法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>同样的，对象语法常常结合返回对象的计算属性使用。</p>
</blockquote>
</li>
<li><p>数组语法：style后面跟的是一个数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>对于一些复杂的逻辑，可以使用计算属性。计算属性本质还是属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// this 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<br>1.计算属性有getter和setter方法，但是默认使用getter方法，setter方法并不常用<br>2.计算属性与方法的区别在于，计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。</p>
</blockquote>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"count++"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"count--"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 语法糖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"count++"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"count--"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li><p>如果该方法不需要额外参数，那么方法后的()可以不写。<br>如果方法中有一个参数，那么会默认将原生事件event参数传递进去。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"btnClick"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"btnClick('abc', $event)"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- .stop修饰符的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"divClick"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"btnClick"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- .prevent修饰符的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> @<span class="attr">click.prevent</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> @<span class="attr">click.prevent</span>=<span class="string">"doThis"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- .监听某个键盘的键帽 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 键别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keyup.enter</span>=<span class="string">"keyUp"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 键代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.13</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- .once修饰符的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">"btnClick"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>.stop</code> : 调用 <code>event.stopPropagation()</code>，阻止冒泡。</li>
<li><code>.prevent</code>:  调用 <code>event.preventDefault()</code>，阻止默认行为。</li>
<li><code>{keyCode | keyAlias}</code>: 当事件是从特定按键触发时才触发回调。</li>
<li><code>.once</code>: 只触发一次回调。</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="v-if、v-else-if、v-else"><a href="#v-if、v-else-if、v-else" class="headerlink" title="v-if、v-else-if、v-else"></a>v-if、v-else-if、v-else</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">"score &gt;= 90"</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">"score &gt;= 80"</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">"score &gt;= 60"</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="管理可复用元素"><a href="#管理可复用元素" class="headerlink" title="管理可复用元素"></a>管理可复用元素</h3><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。使用<code>key</code>可以禁止元素复用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>v-show的用法和v-if非常相似，也用于决定一个元素是否渲染。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>v-if</code>当条件为false时，并不会有对应的元素在DOM中。</li>
<li><code>v-show</code>当条件为false时，仅仅是将元素的display属性设置为none。</li>
<li>当需要在显示与隐藏之间切换很频繁时，使用<code>v-show</code>。</li>
<li>如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</li>
</ul>
<h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>当一组数据需要进行渲染时，就可以使用<code>v-for</code>来完成。</p>
<ol>
<li><p>遍历数组<br>格式：<code>item in items</code>  或 <code>(item, index) in items</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1.遍历过程中不使用索引值（下标）--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.message"</span>&gt;</span>&#123;&#123; item.message &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--2.遍历过程中获取索引值--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span>&#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exam = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历对象<br>格式：<code>value in object</code>  或 <code>(value, name) in object</code> 或 <code>(value, name, index) in object</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.在遍历对象过程中，只获取一个值，那么获取到的是vlaue--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in info"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.获取key和value的格式：(value, key)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value, key) in info"</span>&gt;</span>&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.获取key和value和index的格式：(value, key， index)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value, key, index) in info"</span>&gt;</span>&#123;&#123;index&#125;&#125;.&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        info: &#123;</span><br><span class="line">            name: <span class="string">'abc'</span>,</span><br><span class="line">            age: <span class="number">25</span>,</span><br><span class="line">            height: <span class="number">180</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="key属性"><a href="#key属性" class="headerlink" title="key属性"></a>key属性</h3><p>当 Vue 更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 的<code>key</code> 属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><p>Vue中包含了一组变更数组的方法，使用它们改变数组也会触发视图的更新。</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.push方法: 在数组末尾增加元素</span></span><br><span class="line"><span class="keyword">this</span>.letters.push(<span class="string">'aaa'</span>)</span><br><span class="line"><span class="keyword">this</span>.letters.push(<span class="string">'aa'</span>, <span class="string">'bb'</span>, <span class="string">'cc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.pop方法: 删除数组中最后一个元素</span></span><br><span class="line"><span class="keyword">this</span>.letters.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//shift方法：删除数组中的第一个元素</span></span><br><span class="line"><span class="keyword">this</span>.letters.shift();</span><br><span class="line"></span><br><span class="line"><span class="comment">//unshift方法：在数组最前面添加元素</span></span><br><span class="line"><span class="keyword">this</span>.letters.unshift(<span class="string">'111'</span>);</span><br><span class="line"><span class="keyword">this</span>.letters.unshift(<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//splice方法：删除元素/插入元素/替换元素</span></span><br><span class="line"><span class="comment">//参数：开始位置，删除个数，增加的元素</span></span><br><span class="line"><span class="keyword">this</span>.letters.splice(<span class="number">1</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">this</span>.letters.splice(<span class="number">4</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort方法：排序</span></span><br><span class="line"><span class="keyword">this</span>.letters.sort();</span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse方法：反转</span></span><br><span class="line"><span class="keyword">this</span>.letters.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：通过索引值修改数组中的元素不是响应式</span></span><br><span class="line"><span class="comment">// this.letters[0] = 'aaa'</span></span><br><span class="line"><span class="comment">//set(要修改的对象，索引值，修改后的值) 或 splice方法</span></span><br><span class="line">Vue.set(<span class="keyword">this</span>.letters, <span class="number">0</span>, <span class="string">'aaa'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>Vue中使用v-model指令来实现表单元素和数据的双向绑定。它会根据控件类型自动选取正确的方法来更新元素。</p>
<p>v-model其实是一个语法糖，它本质上包含两个操作：</p>
<ol>
<li>v-bind绑定一个value属性</li>
<li>v-on指令给当前元素绑定input事件</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-bind:value</span>=<span class="string">"message"</span> <span class="attr">v-on:input</span>=<span class="string">"message = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="单选按钮-radio"><a href="#单选按钮-radio" class="headerlink" title="单选按钮(radio)"></a>单选按钮(radio)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只能选一个的单选框需要有相同的name，但是使用v-model后，可以不加name属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"male"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"男"</span> <span class="attr">v-model</span>=<span class="string">"gender"</span> <span class="attr">id</span>=<span class="string">"male"</span>&gt;</span>男</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"female"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"女"</span> <span class="attr">v-model</span>=<span class="string">"gender"</span> <span class="attr">id</span>=<span class="string">"female"</span>&gt;</span>女</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>性别是：&#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="复选框-checkbox"><a href="#复选框-checkbox" class="headerlink" title="复选框(checkbox)"></a>复选框(checkbox)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. checkbox单选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"agree"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"agree"</span> <span class="attr">v-model</span>=<span class="string">"isAgree"</span>&gt;</span>同意协议</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择是：&#123;&#123;isAgree&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.checkbox多选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"唱"</span> <span class="attr">v-model</span>=<span class="string">"hobbies"</span>&gt;</span>唱</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"跳"</span> <span class="attr">v-model</span>=<span class="string">"hobbies"</span>&gt;</span>跳</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"rap"</span> <span class="attr">v-model</span>=<span class="string">"hobbies"</span>&gt;</span>rap</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"篮球"</span> <span class="attr">v-model</span>=<span class="string">"hobbies"</span>&gt;</span>篮球</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的爱好是：&#123;&#123;hobbies&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isAgree: <span class="literal">false</span>,</span><br><span class="line">        hobbies: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>单个复选框：</p>
<ul>
<li>v-model即为布尔值。</li>
<li>此时input的value值并不影响v-model的值。</li>
</ul>
<p>多个复选框：</p>
<ul>
<li>因为可以选中多个，所以对应的data中属性是一个数组。</li>
<li>选中某一个时，就会将input的value值添加到数组中。</li>
</ul>
<h3 id="选择框-select"><a href="#选择框-select" class="headerlink" title="选择框(select)"></a>选择框(select)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.选择一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"abc"</span> <span class="attr">v-model</span>=<span class="string">"fruit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"苹果"</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"香蕉"</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"榴莲"</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"葡萄"</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的水果是:&#123;&#123;fruit&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.选择多个 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 要按住ctrl才能多选 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"abc"</span> <span class="attr">v-model</span>=<span class="string">"fruits"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"苹果"</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"香蕉"</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"榴莲"</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"葡萄"</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的水果是：&#123;&#123;fruits&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>单选：</p>
<ul>
<li>v-model绑定的是一个值。</li>
<li>选中option中的一个时，将它对应的value赋值到data中的相应数据。</li>
</ul>
<p>多选：</p>
<ul>
<li>v-model绑定的是一个数组。</li>
<li>选中多个值时，将选中的option对应的value添加到数组中。</li>
</ul>
<h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><p>对于单选按钮，复选框及选择框的选项，v-model绑定的值通常是静态字符串 (对于复选框也可以是布尔值)。但是在开发中，这些input的值可能是从网络获取或定义在data中的。所以可以通过<code>v-bind:value</code>动态的给value绑定值。</p>
<h3 id="修饰符-1"><a href="#修饰符-1" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.修饰符：lazy --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.lazy</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.修饰符：number --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125;-&#123;&#123;typeof age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3.修饰符：trim --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.trim</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>你的用户名是：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>.lazy</code>修饰符<br>默认情况下，v-model默认是在input事件中同步输入框的数据的。也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。<code>.lazy</code>修饰符可以让数据在失去焦点或者回车时才会更新.</p>
</li>
<li><p><code>.number</code>修饰符<br>默认情况下，在输入框中无论输入的是字母还是数字，都会被当做字符串类型进行处理。<code>.number</code>修饰符自动将用户的输入值转为数值类型。</p>
</li>
<li><p><code>.trim</code>修饰符<br>自动过滤用户输入的首尾空白字符。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery笔记</title>
    <url>/2020/07/13/jQuery%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>jQuery是一个封装了很多方法的js库。</p>
<a id="more"></a>

<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p><a href="http://jquery.com/download/" target="_blank" rel="noopener">下载地址</a><br>1.x版本：能够兼容IE678浏览器<br>2.x版本：不兼容IE678浏览器<br>1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。<br>3.x版本不兼容IE678，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678）</p>
<p>每个版本都有压缩版和未压缩版，如：<br>jquery-1.12.4.min.js: 压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。<br>jquery-1.12.4.js: 未压缩版本，适用于学习与开发环境，源码清晰，易阅读。</p>
<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">或</span><br><span class="line">$(function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>jQuery入口函数与js入口函数的对比:<br>执行时机不同，jQuery入口函数要先于js入口函数执行。<br>jQuery入口函数要等待页面上的DOM树加载完后执行。<br>js入口函数要等待页面上所有资源(DOM树/外部css/js链接/图片)都加载完后执行。</p>
<h3 id="jQuery对象与DOM对象的区别"><a href="#jQuery对象与DOM对象的区别" class="headerlink" title="jQuery对象与DOM对象的区别"></a>jQuery对象与DOM对象的区别</h3><ol>
<li><p>jQuery对象是使用jQuery的方法获取页面中的元素返回的对象(<strong>伪数组</strong>)。</p>
</li>
<li><p>DOM对象是使用JavaScript中的方法获取页面中的元素返回的对象。</p>
</li>
<li><p>DOM对象与jQuery对象的方法不能混用，只能调用自己的方法或属性。</p>
</li>
<li><p>jQuery对象其实就是DOM对象的包装集，即包装了DOM对象的集合。<br>相互转换：</p>
</li>
<li><p>DOM对象转换成jQuery对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $obj = $(domObj);</span><br><span class="line"><span class="comment">// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>jQuery对象转换成DOM对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(“li”);</span><br><span class="line"></span><br><span class="line">$li[<span class="number">0</span>] </span><br><span class="line">或</span><br><span class="line">$li.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="符号的实质"><a href="#符号的实质" class="headerlink" title="$符号的实质"></a>$符号的实质</h3><p>$实质上是一个函数，使用时要加括号<code>$()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($ === jQuery);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>传入参数不同，功能就不同：</p>
<ol>
<li><p>参数是function时是入口函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>参数是DOM对象时，把DOM对象转换成jQuery对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>参数是字符串时，用于获取指定对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;div&#39;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><p>jQuery选择器是jQuery提供的一组方法，可以更加方便的获取到页面中的元素，并且基本兼容了CSS1到CSS3所有的选择器。</p>
<blockquote>
<p> 注意：jQuery选择器返回的是jQuery对象。</p>
</blockquote>
<h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th>用法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ID选择器</td>
<td>$(“#id”);</td>
<td align="left">获取指定ID的元素</td>
</tr>
<tr>
<td align="left">类选择器</td>
<td>$(“.class”);</td>
<td align="left">获取同一类class的元素</td>
</tr>
<tr>
<td align="left">标签选择器</td>
<td>$(“div”);</td>
<td align="left">获取同一类标签的所有元素</td>
</tr>
<tr>
<td align="left">并集选择器</td>
<td>$(“div,p,li”);</td>
<td align="left">使用逗号分隔，只要符合条件之一就可。</td>
</tr>
<tr>
<td align="left">交集选择器</td>
<td>$(“div.redClass”);</td>
<td align="left">获取class为redClass的div元素</td>
</tr>
</tbody></table>
<h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>子代选择器</td>
<td>$(“ul&gt;li”);</td>
<td align="left">使用&gt;号，获取儿子层级的元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>$(“ul li”);</td>
<td align="left">使用空格，获取ul下的所有li元素</td>
</tr>
</tbody></table>
<h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>用</th>
</tr>
</thead>
<tbody><tr>
<td>:eq（index）</td>
<td>$(“li:eq(2)”).css(“color”, ”red”);</td>
<td>获取到的i元素中，选择索引号为2的元素(索引号从0开始)</td>
</tr>
<tr>
<td>:odd</td>
<td>$(“li:odd”).css(“color”, ”red”);</td>
<td>获取到的i元素中，选择索引号为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$(“li:even”).css(“color”, ”red”);</td>
<td>获取到的li元素中，选择索引号为偶数的元素</td>
</tr>
</tbody></table>
<h3 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h3><p>与过滤选择器不同的地方在于，筛选选择器是<strong>方法</strong>。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>children(selector)</td>
<td>$(“ul”).children(“li”)</td>
<td align="left">相当于$(“ul&gt;li”)，子代选择器</td>
</tr>
<tr>
<td>find(selector)</td>
<td>$(“ul”).find(“li”);</td>
<td align="left">相当于$(“ul li”)，后代选择器</td>
</tr>
<tr>
<td>siblings(selector)</td>
<td>$(“#first”).siblings(“li”);</td>
<td align="left">查找兄弟节点，不包括自己本身。</td>
</tr>
<tr>
<td>parent()</td>
<td>$(“#first”).parent();</td>
<td align="left">查找父亲</td>
</tr>
<tr>
<td>eq(index)</td>
<td>$(“li”).eq(2);</td>
<td align="left">相当于$(“li:eq(2)”),index从0开始</td>
</tr>
<tr>
<td>next()</td>
<td>$(“li”).next()</td>
<td align="left">找下一个兄弟</td>
</tr>
<tr>
<td>prev()</td>
<td>$(“li”).prev()</td>
<td align="left">找上一次兄弟</td>
</tr>
</tbody></table>
<h3 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h3><p>遍历内部DOM元素(伪数组形式)的过程，即给匹配到的所有元素进行循环遍历并执相应方法，简化了操作。</p>
<h2 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h2><h3 id="css操作"><a href="#css操作" class="headerlink" title="css操作"></a>css操作</h3><ol>
<li><p>获取样式，参数只写属性名，则返回属性值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).css("属性名")</span></span><br><span class="line">$(<span class="string">".one"</span>).css(<span class="string">"color"</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>设置单个样式，参数是属性名和属性值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).css("属性名"，"属性值") 值如果是数字，可以不加引号</span></span><br><span class="line">$(<span class="string">".one"</span>).css(<span class="string">"color"</span>, <span class="string">"red"</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>设置多个样式，参数是一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).css(obj)</span></span><br><span class="line">$(<span class="string">".one"</span>).css(&#123;</span><br><span class="line">    <span class="string">"width"</span>: <span class="string">"400px"</span>,</span><br><span class="line">    <span class="string">"height"</span>: <span class="string">"200px"</span>,</span><br><span class="line">    <span class="string">"backgroundColor"</span>: <span class="string">"pink"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>​      隐式迭代会给多个元素设置相同的值，而执行获取操作时，只会返回第一个元素的值。</p>
</blockquote>
</li>
</ol>
<h3 id="class操作"><a href="#class操作" class="headerlink" title="class操作"></a>class操作</h3><ol>
<li>添加样式类<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).addClass("className")</span></span><br><span class="line"><span class="comment">// 给所有div添加one样式</span></span><br><span class="line">$(<span class="string">"div"</span>).addClass(<span class="string">"one"</span>);</span><br></pre></td></tr></table></figure></li>
<li>移除样式类<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).removeClass("className")</span></span><br><span class="line"><span class="comment">// 移除div中的one样式类名</span></span><br><span class="line">$(<span class="string">"div"</span>).removeClass(<span class="string">"one"</span>);</span><br></pre></td></tr></table></figure></li>
<li>判断是否有某个样式类<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).hasClass("className") 返回值为布尔值</span></span><br><span class="line"><span class="comment">// 判断第一个div是否有one样式类</span></span><br><span class="line">$(<span class="string">"div"</span>).hasClass(<span class="string">"one"</span>);</span><br></pre></td></tr></table></figure></li>
<li>切换样式类<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).toggleClass("className") 若有则移除该样式，若没有则添加该样式</span></span><br><span class="line">$(<span class="string">"div"</span>).toggleClass(<span class="string">"one"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h2><h3 id="attr方法"><a href="#attr方法" class="headerlink" title="attr方法"></a>attr方法</h3><ol>
<li><p>获取属性，参数只写属性名，则返回属性值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).attr("name")</span></span><br><span class="line"><span class="comment">// 获取img标签的title属性</span></span><br><span class="line"> $(<span class="string">"img"</span>).attr(<span class="string">"title"</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>设置单个属性，参数是属性名和属性值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).attr("name", "vlaue")</span></span><br><span class="line"> $(<span class="string">"img"</span>).attr(<span class="string">"title"</span>, <span class="string">"photo"</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>设置多个属性，参数是一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).attr(obj)</span></span><br><span class="line">$(<span class="string">"img"</span>).attr(&#123;</span><br><span class="line">	<span class="string">"title"</span>: <span class="string">'photo'</span>,</span><br><span class="line">	<span class="string">"alt"</span>: <span class="string">'aaa'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以设置自定义属性</p>
</blockquote>
</li>
<li><p>移除属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">removeAttr(&quot;name&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="prop方法"><a href="#prop方法" class="headerlink" title="prop方法"></a>prop方法</h3><p>在jQuery1.6之后，对于布尔类型的属性，不能用attr方法，因为attr方法对于未设置的属性，返回值是undefined。而checked/selected/disabled等属性，未设置时返回值应是false，此时要用prop方法，两种方法用法相同。</p>
<ol>
<li><p>获取属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).prop("name") </span></span><br><span class="line">$(<span class="string">"input"</span>).prop(<span class="string">"checked"</span>);  <span class="comment">// 返回值为true或false</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(selector).prop("name","value") </span></span><br><span class="line">$(<span class="string">"input"</span>).prop(<span class="string">"checked"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>jQuery提供了三组基本动画，这些动画都是标准的、有规律的效果，另外jQuery还提供了自定义动画的功能功能。</p>
<h3 id="三组基本动画"><a href="#三组基本动画" class="headerlink" title="三组基本动画"></a>三组基本动画</h3><ol>
<li>显示与隐藏（show、hide）</li>
<li>滑入、滑出与切换（slideDown、slideUp、slideToggle）</li>
<li>淡入、淡出与切换（fadeIn、fadeOut、fadeToggle）<br>用法相同：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).show([speed], [callback]); <span class="comment">// speed为动画执行时间</span></span><br><span class="line"><span class="comment">// 1. show与hide不传参数就没有动画效果，其它不传参数默认值为normal</span></span><br><span class="line"><span class="comment">// 2. speed可以是毫秒值，也可以是固定字符串slow(200ms)、normal(400ms)、fast(600ms)。如果传入其它字符，则默认为normal</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p>animate方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).animate(&#123;params&#125;, [speed], [easing], [callback]);</span><br><span class="line"><span class="comment">// &#123;params&#125;: 要执行动画的样式属性以及值</span></span><br><span class="line"><span class="comment">// speed: 执行动画的时长</span></span><br><span class="line"><span class="comment">// easin: 动画效果，默认为swing(缓动)，还可以是linear(匀速)</span></span><br><span class="line"><span class="comment">// callback: 回调函数</span></span><br></pre></td></tr></table></figure>

<h3 id="动画队列与停止动画"><a href="#动画队列与停止动画" class="headerlink" title="动画队列与停止动画"></a>动画队列与停止动画</h3><p>在同一个元素上执行多个动画，会将一系列动画放入动画队列中依次执行。好处是可以让动画按顺序执行，坏处是要占用一定的时间。<br>stop方法：停止<strong>当前正在执行</strong>的动画。(在animate方法前使用)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stop(clearQueue, jumpToEnd);</span><br><span class="line"><span class="comment">// clearQueue: 是否清除动画队列 true/false</span></span><br><span class="line"><span class="comment">// jumpToEnd: 是否跳转到当前动画最终效果 true/false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数一般不使用</p>
</blockquote>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(htmlStr) 括号内为html格式的字符串</span></span><br><span class="line">$(<span class="string">"&lt;span&gt;这是一个span元素&lt;/span&gt;"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.添加到子元素后</span></span><br><span class="line">$(father).append(child);</span><br><span class="line">$(child).appendTo(father);</span><br><span class="line"><span class="comment">// 2. 添加到子元素前</span></span><br><span class="line">$(father).prepend(child);</span><br><span class="line">$(child).prependTo(father);</span><br><span class="line"><span class="comment">// 3. 添加到元素前(兄弟节点)</span></span><br><span class="line">$(<span class="string">"div"</span>).before(<span class="string">"p"</span>);</span><br><span class="line"><span class="comment">// 3. 添加到元素后(兄弟节点)</span></span><br><span class="line">$(<span class="string">"div"</span>).after(<span class="string">"p"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>appendTo()括号内可不加$直接写成appendTo(“#id”)，但是append不可以。</p>
</blockquote>
<h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).clone();</span><br><span class="line"><span class="comment">// 参数为布尔值，默认为false</span></span><br><span class="line"><span class="comment">// false: 深度复制，但不会复制事件</span></span><br><span class="line"><span class="comment">// true: 深度复制，会复制事件</span></span><br></pre></td></tr></table></figure>

<h3 id="清空节点与删除节点"><a href="#清空节点与删除节点" class="headerlink" title="清空节点与删除节点"></a>清空节点与删除节点</h3><ol>
<li>清空节点<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).html(<span class="string">""</span>); <span class="comment">// 不推荐，会造成内存泄漏，且绑定的事件不会清除</span></span><br><span class="line">$(selector).empty(); <span class="comment">// 清除子元素，自身会保留</span></span><br></pre></td></tr></table></figure></li>
<li>删除节点<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).remove(); <span class="comment">// 自身也移除</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="特殊属性操作"><a href="#特殊属性操作" class="headerlink" title="特殊属性操作"></a>特殊属性操作</h2><h3 id="val方法"><a href="#val方法" class="headerlink" title="val方法"></a>val方法</h3><p>用于获取和设置表单元素的值，如input、textarea等。</p>
<ol>
<li><p>获取值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).val();</span><br></pre></td></tr></table></figure></li>
<li><p>设置值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).val(<span class="string">"值"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="html方法和text方法"><a href="#html方法和text方法" class="headerlink" title="html方法和text方法"></a>html方法和text方法</h3><p>html方法相当于innerHTML，text方法相当于innerText。<br>html方法会识别标签，text方法并不会。</p>
<h3 id="width方法和height方法"><a href="#width方法和height方法" class="headerlink" title="width方法和height方法"></a>width方法和height方法</h3><p>获取或设置宽度和高度。</p>
<ol>
<li><p>获取宽度和高度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).width();  <span class="comment">// width</span></span><br><span class="line">$(selector).height();</span><br><span class="line">$(selector).innerwidth();  <span class="comment">// padding + width</span></span><br><span class="line">$(selector).outerwidth();  <span class="comment">// padding + width +border</span></span><br><span class="line">$(selector).outerwidth(<span class="literal">true</span>);  <span class="comment">// padding + width +border + margin</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置宽度和高度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).width(<span class="number">233</span>);</span><br><span class="line">$(selector).height(<span class="number">233</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="scrollTop方法和scrollLeft方法"><a href="#scrollTop方法和scrollLeft方法" class="headerlink" title="scrollTop方法和scrollLeft方法"></a>scrollTop方法和scrollLeft方法</h3><p>获取或设置被卷去的长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).scrollTop();</span><br><span class="line">$(selector).scrollLeft();</span><br><span class="line"><span class="comment">// 页面被卷去高度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>  js中的scrollTop属性是元素属性，页面被卷去高度使用window.pageYOffset(只读)</p>
</blockquote>
<h3 id="offset方法与position方法"><a href="#offset方法与position方法" class="headerlink" title="offset方法与position方法"></a>offset方法与position方法</h3><p>offset方法获取元素距离document的位置。<br>position方法获取的是元素距离有定位的父元素的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取元素距离document的位置,返回值为对象</span></span><br><span class="line">$(selector).offset();</span><br><span class="line"><span class="comment">//获取相对于其最近的有定位的父元素的位置。（不能传参）</span></span><br><span class="line">$(selector).position();</span><br></pre></td></tr></table></figure>

<h2 id="jQuery事件机制"><a href="#jQuery事件机制" class="headerlink" title="jQuery事件机制"></a>jQuery事件机制</h2><h3 id="jQuery事件发展历程-了解"><a href="#jQuery事件发展历程-了解" class="headerlink" title="jQuery事件发展历程(了解)"></a>jQuery事件发展历程(了解)</h3><p>简单事件绑定–&gt;bind事件绑定–&gt;delegate事件绑定–&gt;on事件绑定(推荐)</p>
<ol>
<li><p>简单事件注册</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">click(handler)            单击事件</span><br><span class="line">mouseenter(handler)        鼠标进入事件</span><br><span class="line">mouseleave(handler)        鼠标离开事件</span><br></pre></td></tr></table></figure>
<p>缺点：不能让同时注册多个事件。</p>
</li>
<li><p>bind方式注册事件<br>可以一次注册多个事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind(事件类型, 事件处理程序)</span></span><br><span class="line">$(<span class="string">"p"</span>).bind(<span class="string">"click mouseenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//事件响应方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>缺点：不支持动态事件绑定。</p>
</li>
<li><p>delegate注册委托事件<br>给父元素注册时间，最终还是由子元素执行。（冒泡原理）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(parent).delegate(selector，事件类型，事件处理函数)</span></span><br><span class="line">$(<span class="string">".parentBox"</span>).delegate(<span class="string">"p"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//为 .parentBox下面的所有的p标签绑定事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>缺点：只能注册委托事件。</p>
</li>
</ol>
<h3 id="on注册事件"><a href="#on注册事件" class="headerlink" title="on注册事件"></a>on注册事件</h3><p>jQuery1.7之后，jQuery用on统一了所有事件的处理方法。<br>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).on(events[,selector][,data],handler);</span><br><span class="line"><span class="comment">// events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</span></span><br><span class="line"><span class="comment">// selector, 执行事件的后代元素，如果没有后代元素，那么事件将有自己执行。</span></span><br><span class="line"><span class="comment">// data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）</span></span><br><span class="line"><span class="comment">// handler，事件处理函数</span></span><br></pre></td></tr></table></figure>
<ol>
<li>注册简单事件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给$(selector)绑定事件，并且由自己触发，不支持动态绑定。</span></span><br><span class="line">$(selector).on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure></li>
<li>注册委托事件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定</span></span><br><span class="line">$(selector).on( <span class="string">"click"</span>,“span”, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &lt;span&gt;&lt;/span&gt;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 注册委托事件时，this的指向。</p>
</blockquote>
</li>
</ol>
<h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><ol>
<li>unbind方法（不用）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解绑所有的事件</span></span><br><span class="line">$(selector).unbind(); </span><br><span class="line"><span class="comment">// 解绑指定的事件</span></span><br><span class="line">$(selector).unbind(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure></li>
<li>undelegate方法（不用）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解绑所有的delegate事件</span></span><br><span class="line">$( selector ).undelegate(); </span><br><span class="line"><span class="comment">// 解绑所有的click事件</span></span><br><span class="line">$( selector).undelegate( “click” );</span><br></pre></td></tr></table></figure></li>
<li>off方法（推荐）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解绑匹配元素的所有事件</span></span><br><span class="line">$(selector).off();</span><br><span class="line"><span class="comment">// 解绑匹配元素的所有click事件</span></span><br><span class="line">$(selector).off(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发click事件</span></span><br><span class="line">$(selector).click(); </span><br><span class="line">$(selector).trigger(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="jQuery事件对象"><a href="#jQuery事件对象" class="headerlink" title="jQuery事件对象"></a>jQuery事件对象</h3><p>jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;screenX和screenY    对应屏幕最左上角的值</span><br><span class="line">&#x2F;&#x2F;clientX和clientY    距离页面左上角的位置（忽视滚动条）</span><br><span class="line">&#x2F;&#x2F;pageX和pageY    距离页面最顶部的左上角的位置（会计算滚动条的距离）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;event.keyCode    按下的键盘代码</span><br><span class="line">&#x2F;&#x2F;event.data    存储绑定事件时传递的附加数据</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;event.stopPropagation()    阻止事件冒泡行为</span><br><span class="line">&#x2F;&#x2F;event.preventDefault()    阻止浏览器默认行为</span><br><span class="line">&#x2F;&#x2F;return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</span><br></pre></td></tr></table></figure>

<h2 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h2><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><p>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">end(); </span><br><span class="line"><span class="comment">// 筛选选择器会改变jQuery对象内的DOM对象，用end()回复到上一次的状态，并且返回匹配元素之前的状态。</span></span><br></pre></td></tr></table></figure>

<h3 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h3><p>jQuery的隐式迭代会对所有的DOM对象设置相同的值，如果需要给每一个对象设置不同的值的，有以下两种方法。</p>
<ol>
<li>利用for循环进行迭代</li>
<li>使用each方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;&#125;);</span><br><span class="line"><span class="comment">// index: 当前元素在所有匹配元素中的索引号</span></span><br><span class="line"><span class="comment">// element: 当前元素（DOM对象）</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><p>jQuery使用$作为标识符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放$的控制权,并且把$的能力给c</span></span><br><span class="line"><span class="keyword">var</span> c = $.noConflict();</span><br></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>jQuery不可能包含所有的功能，所以可以通过插件扩展jQuery的功能。<br>使用步骤：</p>
<ol>
<li>引入jQuery文件</li>
<li>引入插件(如果有用到css的话，还需要引入css)</li>
<li>使用插件</li>
</ol>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><ol>
<li>jquery.color.js<br>animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。(颜色尽量使用十六进制)</li>
<li>jquery.ui.js<br>jQueryUI专指由jQuery官方维护的UI方向的插件。<br>使用：<ul>
<li>引入jQueryUI的样式文件</li>
<li>引入jQuery文件</li>
<li>引入jQueryUI的js文件</li>
<li>使用jQueryUI的功能</li>
</ul>
</li>
</ol>
<h3 id="制作插件"><a href="#制作插件" class="headerlink" title="制作插件"></a>制作插件</h3><p>jquery插件实质上就是给jQuery对象增加一个新的方法，让jQuery对象拥有某一个功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过给$.fn添加方法就能够扩展jquery对象</span></span><br><span class="line">$.fn.pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>恢复Hexo博客</title>
    <url>/2020/07/12/%E6%81%A2%E5%A4%8DHexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>重装系统后需要恢复Hexo博客，记录下过程。</p>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node</span><br><span class="line">npm</span><br><span class="line">git</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="配置git个人信息"><a href="#配置git个人信息" class="headerlink" title="配置git个人信息"></a>配置git个人信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot; &quot;  &#x2F;&#x2F; github登录用户名</span><br><span class="line">git config --global user.email  &quot; &quot;   &#x2F;&#x2F; github注册邮箱</span><br></pre></td></tr></table></figure>

<h2 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot; &quot;  &#x2F;&#x2F; 邮箱地址</span><br></pre></td></tr></table></figure>
<p>找到<code>C:\Users\lenovo\.ssh</code>目录下的<code>id_rsa.pub</code>文件，复制内容，打开你的github主页，选择个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，将复制到内容粘贴到Key中，最后删除原来的公钥。<br>测试是否配置成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<h2 id="删除部分博客文件夹"><a href="#删除部分博客文件夹" class="headerlink" title="删除部分博客文件夹"></a>删除部分博客文件夹</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除以下文件：</span><br><span class="line">.deploy_git</span><br><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">public</span><br></pre></td></tr></table></figure>

<h2 id="关联github项目"><a href="#关联github项目" class="headerlink" title="关联github项目"></a>关联github项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:youraccount&#x2F;yourproject.git</span><br></pre></td></tr></table></figure>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install –g hexo</span><br></pre></td></tr></table></figure>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>部署成功！</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript笔记04-PC端网页特效</title>
    <url>/2020/07/10/JavaScript%E7%AC%94%E8%AE%B004-PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<h2 id="offset系列"><a href="#offset系列" class="headerlink" title="offset系列"></a>offset系列</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>偏移量，使用offset系列相关属性可以动态的得到该元素的位置(偏移)、大小等。</p>
<ul>
<li>获得元素距离带有定位父元素的位置</li>
<li>获得元素自身大小(宽度高度)</li>
<li>返回的数值不带单位</li>
</ul>
<a id="more"></a>

<p>offset系列常用属性：<br> offset系列属性       | 返回值<br> ——————– | ——————————————————–<br> element.offsetParent | 返回该元素带有定位的父级元素，若父级元素无定位则返回body<br> element.offsetTop    | 返回该元素相对于带有定位的父元素上方的偏移<br> element.offsetLeft   | 返回该元素相对于带有定位的父元素左边框的偏移<br> element.offsetWidth  | 返回自身包括padding、边框、内容区的宽度<br> element.offsetHeight | 返回自身包括padding、边框、内容区的高度                  </p>
<h3 id="offset与style的区别"><a href="#offset与style的区别" class="headerlink" title="offset与style的区别"></a>offset与style的区别</h3><p>offset</p>
<ul>
<li>可以得到任意样式表中的样式值</li>
<li>获得的数值没有单位</li>
<li>包含padding+border+width</li>
<li>只读属性，不能赋值</li>
</ul>
<p>style</p>
<ul>
<li>只能得到行内样式表中的样式值</li>
<li>获得的是有单位的字符串</li>
<li>不包含padding和border的值</li>
<li>可读写属性</li>
</ul>
<blockquote>
<p>总结：<br>​    想要获取元素大小为止，用offset。<br>​    想要给元素更改值，用style。</p>
</blockquote>
<h2 id="client系列"><a href="#client系列" class="headerlink" title="client系列"></a>client系列</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>​    元素可视区，使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p>
<p>client系列常用属性:<br> client系列属性       | 返回值<br> ——————– | ———————————————————–<br> element.clientTop    | 返回元素上边框大小<br> element.clientLeft   | 返回元素左边框大小<br> element.clientWidth  | 返回自身包括padding、内容区的宽度，不含边框，返回值不带单位<br> element.clientHeight | 返回自身包括padding、内容区的高度，不含边框，返回值不带单位 </p>
<h2 id="scroll系列"><a href="#scroll系列" class="headerlink" title="scroll系列"></a>scroll系列</h2><p>使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p>
<table>
<thead>
<tr>
<th>scroll系列属性</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>element.scrollTop</td>
<td>返回被卷的上侧距离，返回值不带单位</td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>返回被卷的左侧距离，返回值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身<strong>实际的</strong>宽度，不含边框，返回值不带单位</td>
</tr>
<tr>
<td>element.scrollHeight</td>
<td>返回自身<strong>实际的</strong>高度，不含边框，返回值不带单位</td>
</tr>
</tbody></table>
<h3 id="被卷去的头部"><a href="#被卷去的头部" class="headerlink" title="被卷去的头部"></a>被卷去的头部</h3><p>​    如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。滚动条向下滚动时，页面上部被隐藏掉的高度称为页面被卷去的头部。滚动条在滚动时会触发 onscroll 事件。<br>​    页面被卷去的头部：<code>window.pageYOffset</code><br>​    页面被卷去的左侧：<code>window.pageXOffset</code></p>
<blockquote>
<p>注意：区分页面被卷去的头部和元素被卷去的头部</p>
</blockquote>
<p>兼容性问题：</p>
<ol>
<li>声明了 DTD，使用 <code>document.documentElement.scrollTop</code></li>
<li>未声明 DTD，使用 <code>document.body.scrollTop</code></li>
<li>新方法 <code>window.pageYOffset</code> 和 <code>window.pageXOffset</code>，IE9 开始支持<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      left: <span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft||<span class="number">0</span>,</span><br><span class="line">      top: <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop || <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 使用时  getScroll().left</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>属性</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>element.offsetWidth</td>
<td>返回自身包括padding、边框、内容区的宽度，返回值不带位</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回自身包括padding、内容区的宽度，不含边框，返回值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身<strong>实际的</strong>宽度，不含边框，返回值不带单位</td>
</tr>
</tbody></table>
<p>用法：</p>
<ol>
<li>offset系列经常用于获得元素位置 ，<code>offsetLeft</code>和<code>offsetTop</code></li>
<li>client系列经常用于获取元素大小，<code>clientWidth</code>和<code>clientHeight</code></li>
<li>scroll系列经常用于获取滚动距离 ，<code>crollTop</code>和<code>scrollLeft</code> </li>
<li>页面滚动的距离通过<code>window.pageXOffset</code> 获得</li>
</ol>
<h2 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h2><h3 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h3><p>核心原理：通过定时器<code>setInterval()</code>不断移动盒子位置。<br>实现步骤：</p>
<ol>
<li>获得盒子当前位置</li>
<li>让盒子在当前位置加上1个移动距离</li>
<li>利用定时器不断重复这个操作</li>
<li>加一个结束定时器的条件</li>
<li>元素需要添加<strong>定位</strong>，才能使用<code>element.style.left</code></li>
</ol>
<h3 id="动画函数简单封装"><a href="#动画函数简单封装" class="headerlink" title="动画函数简单封装"></a>动画函数简单封装</h3><ol>
<li>函数需要传递2个参数，动画对象和移动的距离。</li>
<li>如果多个元素都使用这个动画函数，每次都要用var声明定时器，会占用内存空间，还会导致定时器重名。需要给不同的元素使用不同的定时器。<br>核心原理： JS 是一门动态语言，可以很方便的给当前对象添加属性。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj, target</span>) </span>&#123;</span><br><span class="line">            obj.timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (obj.offsetLeft &gt;= target) &#123;</span><br><span class="line">                    <span class="comment">// 停止动画 本质是停止定时器</span></span><br><span class="line">                    clearInterval(obj.timer);</span><br><span class="line">                &#125;</span><br><span class="line">                obj.style.left = obj.offsetLeft + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">            &#125;, <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="缓动效果原理"><a href="#缓动效果原理" class="headerlink" title="缓动效果原理"></a>缓动效果原理</h3><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来。<br>思路：</p>
<ol>
<li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。</li>
<li>核心算法： (目标值 - 现在的位置 )  /  10  做为每次移动的距离或步长</li>
<li>停止的条件：当前盒子位置等于目标位置，停止定时器 </li>
<li>注意步长值需要取整 </li>
</ol>
<h3 id="动画函数多个目标值之间移动"><a href="#动画函数多个目标值之间移动" class="headerlink" title="动画函数多个目标值之间移动"></a><strong>动画函数多个目标值之间移动</strong></h3><p>动画函数可以让元素在两个位置之间来回移动。<br>点击按钮时，判断步长是正值还是负值</p>
<ol>
<li>如果是正值，则步长往大了取整</li>
<li>如果是负值，则步长向小了取整<h3 id="动画函数添加回调函数"><a href="#动画函数添加回调函数" class="headerlink" title="动画函数添加回调函数"></a><strong>动画函数添加回调函数</strong></h3>回调函数原理：<br>​    将函数作为参数传到另一个函数里，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。<br>回调函数书写位置：定时器结束后。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript笔记03-BOM</title>
    <url>/2020/07/08/JavaScript%E7%AC%94%E8%AE%B003-BOM/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是BOM"><a href="#什么是BOM" class="headerlink" title="什么是BOM"></a>什么是BOM</h3><p>BOM(Browser Object Model)浏览器对象模型，提供了独立与内容的与浏览器窗口进行交互的对象，核心对象是window。</p>
<p>BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 </p>
<p>不同于DOM的标准化组织是W3C，JavaScript的语法标准化组织是ECMA，BOM没有官方标准，它最初是Netscape浏览器标准的一部分。也就是说，对于现代浏览器，每个浏览器都有自己的BOM实现方法，所以直接使用BOM会有兼容性问题。</p>
<a id="more"></a>

<h3 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h3><p>window对象是浏览器的顶级对象，具有双重角色</p>
<ol>
<li>它是JS访问浏览器的一个接口</li>
<li>是一个全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法。在调用的时候可以省略window，如alert()、prompt()等。<blockquote>
<p>注意： window下的一个特殊属性window.name</p>
</blockquote>
</li>
</ol>
<h2 id="window对象的常见事件"><a href="#window对象的常见事件" class="headerlink" title="window对象的常见事件"></a>window对象的常见事件</h2><h3 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a>窗口加载事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;&#125;</span><br><span class="line">或</span><br><span class="line">window.addEventListener(&#39;load&#39;, function() &#123;&#125;)</span><br><span class="line">或</span><br><span class="line">document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>window.onload</code>是窗口(页面)加载事件，当文档内容完全加载完(包括图片、脚本文件、CSS文件等)会触发该事件调用的处理函数。<br><code>DOMContentLoaded</code>事件触发是，仅当DOM加载完成，不包括样式表、图片、flash等。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>有了<code>window.onload</code>就可以把JS代码写到页面元素的上方。</li>
<li><code>window.onload</code>传统注册事件方式只能写一次，如果有多个，会以最后一个为准。</li>
<li>使用<code>addEventListener</code>则没有限制。</li>
<li><code>DOMContentLoaded</code>IE9以上才支持。</li>
<li>如果页面图片很多的话，用户从访问到onload触发可能需要较长的时间，此时使用<code>DOMContentLoaded</code>事件比较合适。</li>
</ol>
</blockquote>
<h3 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onresize &#x3D; function() &#123;&#125;</span><br><span class="line">或</span><br><span class="line">window.addEventListener(&#39;resize&#39;, function() &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>window.onresize</code>是调整窗口大小加载事件，触发时就调用的处理函数</p>
<blockquote>
<p>注意：</p>
<ol>
<li>只要窗口大小发生像素变化，就会触发这个事件。</li>
<li>经常利用这个事件完成响应式布局。使用<code>window.innerWidth</code>获取当前屏幕的宽度。</li>
</ol>
</blockquote>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="setTimeout-定时器"><a href="#setTimeout-定时器" class="headerlink" title="setTimeout()定时器"></a>setTimeout()定时器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.setTimeout(调用函数, [延迟毫秒数]);</span><br></pre></td></tr></table></figure>
<p><code>setTimeout()</code>方法用于设置一个定时器，该定时器在定时器到期后执行调用函数，只调用一次。<br><code>setTimeout()</code>这个调用函数也称为<strong>回调函数(callback)</strong>。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>window可以省略</li>
<li>调用函数可以直接写函数，或者写函数名，或者采取字符串’函数名()’的形式，最后一种不推荐。</li>
<li>延迟的毫秒数默认是0 ，注意单位是毫秒。</li>
<li>定时器可能有很多个，所以一般给定时器赋值一个标识符。</li>
</ol>
</blockquote>
<h3 id="停止setTimeout-定时器"><a href="#停止setTimeout-定时器" class="headerlink" title="停止setTimeout()定时器"></a>停止setTimeout()定时器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.clearTimeout(timeoutID);</span><br></pre></td></tr></table></figure>
<p><code>.clearTimeout()</code>方法取消了先前调用<code>setTimeout()</code>建立的定时器。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>window可以省略。</li>
<li>参数就是定时器的标识符。</li>
</ol>
</blockquote>
<h3 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval()定时器"></a>setInterval()定时器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.setInterval(回调函数, [延迟毫秒数]);</span><br></pre></td></tr></table></figure>
<p><code>setInterval()</code>方法<strong>重复调用</strong>一个函数，每隔指定时间，就调用一次回调函数。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>window可以省略</li>
<li>调用函数可以直接写函数，或者写函数名，或者采取字符串’函数名()’的形式，最后一种不推荐。</li>
<li>延迟的毫秒数默认是0 ，注意单位是毫秒。</li>
<li>定时器可能有很多个，所以一般给定时器赋值一个标识符。</li>
</ol>
</blockquote>
<h3 id="停止setInterval-定时器"><a href="#停止setInterval-定时器" class="headerlink" title="停止setInterval()定时器"></a>停止setInterval()定时器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.clearInterval(timeoutID);</span><br></pre></td></tr></table></figure>
<p><code>.clearInterval()</code>方法取消了先前调用<code>setInterval()</code>建立的定时器。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>window可以省略。</li>
<li>参数就是定时器的标识符。</li>
</ol>
</blockquote>
<h2 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h2><p>一般情况下this的最终指向的是那个调用它的对象</p>
<ol>
<li>全局作用域或者普通函数中this指向全局对象window（ 注意定时器里的this指向window）</li>
<li>方法调用中谁调用this指向谁</li>
<li>构造函数中this指向构造函数的实例</li>
</ol>
<p><strong>事件绑定</strong>中，使用<code>addEventListener</code>绑定事件时，回调函数不能写成<strong>箭头函数</strong>，否则this指向的就不再是事件源。</p>
<h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><p>JavaScript语言的一大特点就是<strong>单线程</strong>，即同一时间只能做一件事。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ol>
<li>同步任务<br>同步任务都在主线程上执行，形成一个<strong>执行栈</strong>。</li>
<li>异步任务<br>JS异步任务是通过回调函数实现的。<br>一般异步任务有以下三种：<ul>
<li>普通事件，如click、resize等</li>
<li>资源加载，如load、error等</li>
<li>定时器，包括setInterval、setTimeout等<br>异步任务相关回调函数添加到<strong>任务队列(消息队列)</strong>中</li>
</ul>
</li>
</ol>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><ol>
<li>先执行执行栈中的同步任务。</li>
<li>异步任务(回调函数)放入任务队列中。</li>
<li>一旦执行栈中的所有同步任务执行完毕，系统会按次序读取任务队列中的异步任务，被读取的异步任务结束等待状态，进入执行栈，开始执行。<br><img src="https://s1.ax1x.com/2020/07/08/UEiYuV.png" alt=""><br>由于主线程不断的重复获得任务、执行任务，这种机制被称为<strong>事件循环(event loop)</strong></li>
</ol>
<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><h3 id="什么是location对象"><a href="#什么是location对象" class="headerlink" title="什么是location对象"></a>什么是location对象</h3><p>window对象提供了一个location属性，用于获取和设置窗体的URL，并且可以解析URL。由于这个属性返回的是一个对象，所以将这个属性也称为location对象。</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源定位符(Uniform Resource Locator)，每一个信息资源都有统一的且在网上唯一的地址，该地址就叫URL。<br>一般语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheme :&#x2F;&#x2F; hostname[:port] &#x2F; path &#x2F; [;parameters][?query]#fragment</span><br><span class="line">http:&#x2F;&#x2F;www.a.com:801&#x2F;index.html?username&#x3D;jes&amp;&amp;country&#x3D;usa#link</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scheme</td>
<td>通信协议，http、ftp等</td>
</tr>
<tr>
<td>hostname</td>
<td>主机（域名）</td>
</tr>
<tr>
<td>port</td>
<td>端口号（可选），省略时使用默认的端口号</td>
</tr>
<tr>
<td>path</td>
<td>路径，由零或多个“/”符号隔开的字符串，一般用来表示主机上的一目录或文件地址</td>
</tr>
<tr>
<td>parameters</td>
<td>参数，是用于指定特殊参数的可选项</td>
</tr>
<tr>
<td>query</td>
<td>查询（可选），以键值对的形式，通过&amp;符号分隔开</td>
</tr>
<tr>
<td>fragment</td>
<td>片段，#后内容，常见于链接、锚点</td>
</tr>
</tbody></table>
<h3 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h3><table>
<thead>
<tr>
<th>location对象属性</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>location.href</td>
<td>获取或者设置整个URL</td>
</tr>
<tr>
<td>location.host</td>
<td>返回主机（域名）</td>
</tr>
<tr>
<td>location.port</td>
<td>返回端口号，未写则返回空字符串</td>
</tr>
<tr>
<td>location.pathname</td>
<td>返回路径</td>
</tr>
<tr>
<td>location.search</td>
<td>返回参数</td>
</tr>
<tr>
<td>location.hash</td>
<td>返回片段</td>
</tr>
<tr>
<td>重点记住：href和search</td>
<td></td>
</tr>
</tbody></table>
<h3 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h3><table>
<thead>
<tr>
<th>location对象方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>location.assign()</td>
<td>与href一样，可以跳转页面（也称为重定向页面）</td>
</tr>
<tr>
<td>location.replace()</td>
<td>替换当前页面，不记录历史，所以不能后退页面</td>
</tr>
<tr>
<td>location.reload()</td>
<td>重新加载页面，相当于刷新(F5)，若参数为true则相当于强制刷新(ctrl+F5)</td>
</tr>
</tbody></table>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>navigator对象包含有关浏览器的信息，有很多属性，最常用的事userAgent，该属性可以返回由客户端发送给服务器的uesr-agent头部的值。<br>判断用户用那个终端打开页面，实现跳转：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">	<span class="built_in">window</span>.location.href = <span class="string">""</span>; <span class="comment">//手机</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">window</span>.location.href = <span class="string">""</span>; <span class="comment">//电脑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history对象包含用户(在浏览器窗口中)访问过的URL。</p>
<table>
<thead>
<tr>
<th>history对象方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>back()</td>
<td>后退功能</td>
</tr>
<tr>
<td>forward()</td>
<td>前进功能</td>
</tr>
<tr>
<td>go(参数)</td>
<td>前进后退功能，若参数是1前进1个页面，-1则后退1个页面</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript笔记02-事件高级</title>
    <url>/2020/07/08/JavaScript%E7%AC%94%E8%AE%B002-%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​    给元素添加事件，称为注册事件或绑定事件。<br>​    方式：传统方式和方法监听注册方式</p>
<a id="more"></a>

<ol>
<li><p>传统注册方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&lt;button onlick=<span class="string">"alert("</span>hi<span class="string">")"</span>&gt;&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>特点：<br>​    注册事件的唯一性，即同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数会覆盖前面注册的处理函数。</p>
</li>
<li><p>方法监听注册方式</p>
<p><code>addEventListener()</code>方法，IE9以上支持，IE9之前采用<code>attachEvent()</code>代替<br>特点：<br>​    同一个元素同一个事件可以注册多个监听器，按注册顺序依次执行。</p>
</li>
</ol>
<h3 id="addEventListener事件监听方法"><a href="#addEventListener事件监听方法" class="headerlink" title="addEventListener事件监听方法"></a>addEventListener事件监听方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evenTarget.addEventListener(type, listener, [useCapture])</span><br></pre></td></tr></table></figure>
<ul>
<li>type：事件类型字符串，如click、mouseover，注意一定不要带on</li>
<li>listener：事件处理函数，事件发生时调用该监听函数</li>
<li>useCapture：可选参数，是一个布尔值，默认为false<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btns.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="number">111</span>);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="attachEvent-事件监听方式"><a href="#attachEvent-事件监听方式" class="headerlink" title="attachEvent 事件监听方式"></a>attachEvent 事件监听方式</h3><p>（一般不用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evenTarget.attachEvent(eventNameWithOn, callback)</span><br></pre></td></tr></table></figure>

<ul>
<li>eventNameWithOn：事件类型字符串，如onlick、onmouseover，需要带on</li>
<li>callback：事件处理函数，目标触发事件时，回调函数</li>
</ul>
<h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><ol>
<li><p>传统方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evenTarget.onclick &#x3D; null;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法监听方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evenTarget.removeEventListener(type, listener, [useCapture]);</span><br><span class="line">evenTarget.detachEvent(eventNameWithOn, callback);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>listener为函数名，不能写匿名函数</p>
</blockquote>
</li>
</ol>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件流：描述了从页面中接收事件的顺序。<br>事件发生时在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流</p>
<p>DOM事件流分为3个阶段：</p>
<ol>
<li>捕获阶段</li>
<li>当前目标阶段</li>
<li>冒泡阶段</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/07/08/UEimB8.jpg" alt="DOM事件流"></p>
<ul>
<li>事件冒泡：IE最早提出，事件开始时由具体元素接收，然后逐级向上传播到DOM最顶层节点的过程</li>
<li>事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程</li>
</ul>
<blockquote>
<p>注意：</p>
<ol>
<li>JS 代码中只能执行捕获或者冒泡其中的一个阶段。</li>
<li>onclick 和 attachEvent 只能得到冒泡阶段。</li>
<li>如果<code>addEventListener(type, listener[, useCapture])</code>第三个参数是 true 表示事件在捕获阶段，若为false或默认，则表示冒泡阶段。</li>
<li>实际开发中很少使用事件捕获，更关注事件冒泡。</li>
<li>有些时间是没有冒泡的，如onblur、onfocus、onmouseenter、onmouseleave。</li>
<li>事件冒泡有时会带来麻烦，有时又可以巧妙地做某些事情。</li>
</ol>
</blockquote>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventTarget.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;</span><br><span class="line">eventTarget.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;)</span><br><span class="line"><span class="comment">// event就是事件对象，一般还可写成e或evt</span></span><br></pre></td></tr></table></figure>

<ol>
<li>event代表事件的状态，如键盘案件的状态、鼠标的位置、鼠标按钮的状态。即事件发生后，与事件相关的一系列信息数据的集合都放在实践对象event中，它有很多属性和方法。</li>
<li>event是系统帮助设定的事件对象，实际不需要传递参数，注册事件时，event对象会被系统自动创建，并依次传递给事件处理函数。</li>
<li>IE6~8中会有兼容性问题，需要使用<code>window.event</code>。<br>解决方法： <code>e = e || window.event</code></li>
</ol>
<h3 id="事件对象常见属性和方法"><a href="#事件对象常见属性和方法" class="headerlink" title="事件对象常见属性和方法"></a>事件对象常见属性和方法</h3><table>
<thead>
<tr>
<th align="left">事件对象属性方法</th>
<th>明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">e.target</td>
<td>返回触发事件对象       准</td>
</tr>
<tr>
<td align="left">e.srcElement</td>
<td>返回触发事件对象       ie6-8用</td>
</tr>
<tr>
<td align="left">e.type</td>
<td>返回事件类型       比如click mouseover 不带n</td>
</tr>
<tr>
<td align="left">e.cancleBubble</td>
<td>该属性阻止冒泡        ie6-8用</td>
</tr>
<tr>
<td align="left">e.returnValue</td>
<td>该属性阻止默认事件（默认行为）    ie6-8使用 例如不让链接转</td>
</tr>
<tr>
<td align="left">e.preventDefault</td>
<td>该属性阻止默认事件（默认行为）    标准 例如不让链接转</td>
</tr>
<tr>
<td align="left">e.cancelBubble</td>
<td>阻止冒泡   ie6-8用</td>
</tr>
<tr>
<td align="left">e.stopPropagation</td>
<td>阻止冒泡       标准</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<ol>
<li>e.target返回触发事件的对象，this返回绑定事件的对象。</li>
<li>currentTarget与this相似，但是有兼容性问题。</li>
<li><code>return false</code>也可以阻止默认行为，但是只限于传统的注册事件方式。</li>
</ol>
</blockquote>
<h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><p><code>MouseEvent</code></p>
<table>
<thead>
<tr>
<th align="left">鼠标事件对象</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">e.clientX</td>
<td align="left">返回鼠标相对于浏览器窗口可视区的X坐标</td>
</tr>
<tr>
<td align="left">e.clientY</td>
<td align="left">返回鼠标相对于浏览器窗口可视区的Y坐标</td>
</tr>
<tr>
<td align="left">e.pageX</td>
<td align="left">返回鼠标相对于文档页面的X坐标    IE9+支持</td>
</tr>
<tr>
<td align="left">e.pageY</td>
<td align="left">返回鼠标相对于文档页面的Y坐标    IE9+支持</td>
</tr>
<tr>
<td align="left">e.screenX</td>
<td align="left">返回鼠标相对于电脑屏幕的X坐标</td>
</tr>
<tr>
<td align="left">e.screenY</td>
<td align="left">返回鼠标相对于电脑屏幕的Y坐标</td>
</tr>
</tbody></table>
<h3 id="键盘事件对象"><a href="#键盘事件对象" class="headerlink" title="键盘事件对象"></a>键盘事件对象</h3><table>
<thead>
<tr>
<th>键盘事件对象 属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.keyCode</td>
<td>返回该键的ASCII值</td>
</tr>
</tbody></table>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>也称事件代理，在jQuery里面称为事件委派</p>
<ol>
<li><p>原理：<br>​    无需给每个子节点单独设置事件监听器，而将事件监听器设置在其父节点上，利用冒泡原理进而影响每个子节点。</p>
</li>
<li><p>优点：<br>​    只操作了一次DOM，提高了程序性能。</p>
</li>
</ol>
<h2 id="常用的鼠标事件"><a href="#常用的鼠标事件" class="headerlink" title="常用的鼠标事件"></a>常用的鼠标事件</h2><table>
<thead>
<tr>
<th align="center">事件</th>
<th align="center">触发条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">onclick</td>
<td align="center">鼠标点击左键触发</td>
</tr>
<tr>
<td align="center">onmouseover</td>
<td align="center">鼠标经过触发</td>
</tr>
<tr>
<td align="center">onmouseout</td>
<td align="center">鼠标离开触发</td>
</tr>
<tr>
<td align="center">onmousemove</td>
<td align="center">鼠标移动触发</td>
</tr>
<tr>
<td align="center">onmouseenter</td>
<td align="center">鼠标经过触发</td>
</tr>
<tr>
<td align="center">onmouseleave</td>
<td align="center">鼠标离开触发</td>
</tr>
<tr>
<td align="center">onfocus</td>
<td align="center">获得鼠标焦点触发</td>
</tr>
<tr>
<td align="center">onblur</td>
<td align="center">失去鼠标焦点触发</td>
</tr>
<tr>
<td align="center">1. 禁止鼠标右键菜单</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>   <code>contextmenu</code>主要控制应该何时现实上下文菜单</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'contextmenu'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                e.preventDefault();</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>禁止鼠标选中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'selectstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h3><p>​    mouseover事件中，鼠标经过自身盒子会触发，经过子盒子还会触发。而在mouseenter事件中只会经过自身盒子触发。</p>
<p>原因：mouseenter不会冒泡，同样mouseleave也不会冒泡</p>
<h2 id="常用的键盘事件"><a href="#常用的键盘事件" class="headerlink" title="常用的键盘事件"></a>常用的键盘事件</h2><table>
<thead>
<tr>
<th align="left">事件</th>
<th>触发件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onkeyup</td>
<td>某个键盘按键被松开时发</td>
</tr>
<tr>
<td align="left">onkeydown</td>
<td>某个键盘按键被按下时发</td>
</tr>
<tr>
<td align="left">onkeypress</td>
<td>某个键盘按键被按下时触发，不识别功能键 如ctrl、shift、箭头等</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<ol>
<li>keydown和keyup不区分字母大小写，keypress区分字母大小写。</li>
<li>实际开发中，更多地使用keydown和keyup，因为能识别所有的键。</li>
<li>三个时间的执行顺序为：keydown – keypress – keyup</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客部署问题</title>
    <url>/2020/07/07/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><code>hexo server</code>查看本地服务器，博客上传成功，再使用<code>hexo d</code>命令将博客部署到github上时报错，博客无法上传到github。</p>
<p>报错信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>信息显示22端口连接超时，使用433端口测试git是否可以连接github。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/07/07/UEpOpt.png" alt=""></p>
<p>连接成功。</p>
<p>解决方法：</p>
<ol>
<li><p>打开git的安装目录，找到<code>/etc/ssh/ssh_config</code>文件，在文件末加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新测试是否能连接到github</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/07/07/UEpqfI.png" alt=""></p>
<p>连接成功！</p>
</li>
<li><p>重新部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>成功</p>
</li>
</ol>
<p>参考文章：<a href="https://blog.csdn.net/linton1/article/details/90141555" target="_blank" rel="noopener">https://blog.csdn.net/linton1/article/details/90141555</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript笔记01-DOM</title>
    <url>/2020/07/06/JavaScript%E7%AC%94%E8%AE%B001-DOM/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>DOM</strong> (Document Object Model，文档对象模型) 是W3C组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口。通过这些DOM接口可以改变网页的内容、结构、样式。</p>
<a id="more"></a>

<p>DOM树：</p>
<ul>
<li>文档：document，一个页面就是一个文档</li>
<li>元素：element，页面中所有的标签都是元素</li>
<li>节点：node，网页中所有的内容都是节点（标签、属性、文本、注释等）</li>
</ul>
<blockquote>
<p>DOM把以上内容都可以看做对象</p>
</blockquote>
<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><h3 id="根据ID获取"><a href="#根据ID获取" class="headerlink" title="根据ID获取"></a>根据ID获取</h3><p>使用<code>document.getElementById(&#39;id&#39;)</code>方法</p>
<ol>
<li>参数id是大小写敏感的字符串</li>
<li>返回的是一个元素对象</li>
</ol>
<h3 id="根据标签名获取"><a href="#根据标签名获取" class="headerlink" title="根据标签名获取"></a>根据标签名获取</h3><p>使用<code>document.getElementsByTagName(&#39;tag&#39;)</code>方法</p>
<ol>
<li>返回的是元素对象的集合，以伪数组的形式存储，若要操作里面的元素需要遍历<blockquote>
<p>无论获取到多少元素对象，返回的都是伪数组<br>若没有获取到指定元素，则返回空的伪数组</p>
</blockquote>
</li>
<li>得到的元素是动态的</li>
<li>可以通过<code>element.getElementsByTagName(&#39;tag&#39;)</code>获取某个元素内部所有指定标签名的子元素<blockquote>
<p>父元素必须指明是哪一个元素对象</p>
</blockquote>
</li>
</ol>
<h3 id="根据类名获取"><a href="#根据类名获取" class="headerlink" title="根据类名获取"></a>根据类名获取</h3><p>使用<code>document.getElementsByClassName(&#39;class&#39;)</code>方法</p>
<h3 id="querySelector-和querySelectorAll"><a href="#querySelector-和querySelectorAll" class="headerlink" title="querySelector()和querySelectorAll()"></a>querySelector()和querySelectorAll()</h3><p>使用<code>document.querySelector()</code>方法，返回指定选择器的第一个元素对象。（选择器需要加符号）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过querySelector获取ID为q1的节点：</span></span><br><span class="line"><span class="keyword">var</span> q1 = <span class="built_in">document</span>.querySelector(<span class="string">'#q1'</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>document.querySelectorAll()</code>方法，返回指定选择器的所有元素对象</p>
<h3 id="获取特殊元素"><a href="#获取特殊元素" class="headerlink" title="获取特殊元素"></a>获取特殊元素</h3><ol>
<li>获取body元素<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body <span class="comment">//返回body元素对象</span></span><br></pre></td></tr></table></figure></li>
<li>获取html元素<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement <span class="comment">//返回html元素对象</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​    事件是可以被JavaScript侦测到的行为，即触发响应的机制。</p>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><p>​    事件由事件源、事件类型、事件处理程序三部分组成</p>
<ol>
<li>事件源，即事件被触发的对象</li>
<li>事件类型，如何触发，如鼠标点击、鼠标经过、键盘按下等</li>
<li>事件处理程序，通过函数复制的方式完成</li>
</ol>
<h3 id="执行事件的步骤"><a href="#执行事件的步骤" class="headerlink" title="执行事件的步骤"></a>执行事件的步骤</h3><ol>
<li>获取事件源</li>
<li>注册（绑定）事件</li>
<li>添加事件处理程序（通过函数赋值）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">123</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        var div = document.querySelector('div');</span></span><br><span class="line"><span class="regexp">        div.onclick = function() &#123;</span></span><br><span class="line"><span class="regexp">            console.log('我被选中了');</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><h3 id="元素内容"><a href="#元素内容" class="headerlink" title="元素内容"></a>元素内容</h3><ol>
<li><pre><code class="javascript">element.innerText
&lt;!--￼<span class="number">4</span>--&gt;
识别html标签，读取时保留换行和空格
</code></pre>
</li>
</ol>
<h3 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h3><p><strong>一般属性</strong></p>
<ol>
<li><code>element.属性</code>，获取内置元素属性值（元素本身自带的属性，src、href、title、alt等）    <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取img元素</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>);</span><br><span class="line"><span class="comment">// 设置title属性值</span></span><br><span class="line">img.title = <span class="string">'123'</span>;</span><br><span class="line"><span class="comment">// 设置class属性值</span></span><br><span class="line">img.className = <span class="string">'photo'</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>element.getAttribute(&#39;属性&#39;)</code>，主要获取自定义的属性<br><code>element.setAttribute(&#39;属性&#39;, &#39;值&#39;)</code>，设置自定义属性<br><code>element.removeAttribute(&#39;属性&#39;)</code>，移除属性值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"demo"</span> index=<span class="string">"1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"nav"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 获取元素</span></span><br><span class="line"><span class="regexp">var div = document.querySelector('div');</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 获取自定义属性</span></span><br><span class="line"><span class="regexp">var num = div.getAttribute('index')</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>表单元素属性</strong>（type、value、disabled等）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"输入内容"</span>&gt;</span><br><span class="line"><span class="comment">// 获取input元素</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>);</span><br><span class="line"><span class="comment">// 修改属性值</span></span><br><span class="line">input.value = <span class="string">'被点击了'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>样式属性</strong>，样式需使用驼峰式命名</p>
<ol>
<li><code>element.style</code>，行内样式操作，权重比较高，适合样式较少或功能简单的情况。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.style.color = <span class="string">'#ff0000'</span>;</span><br><span class="line">p.style.fontSize = <span class="string">'20px'</span>;</span><br><span class="line">p.style.paddingTop = <span class="string">'2em'</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>element.className</code>，类名样式操作，适合功能较多或样式复杂的情况。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在css中定义样式</span></span><br><span class="line">.change &#123;</span><br><span class="line">           background-color: purple;</span><br><span class="line">           color: #fff;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">p.className = <span class="string">'change'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>​    className会直接更改元素类名，并且会覆盖原先的类名<br>​    若要保留原先的类名，可使用<code>element.className = &#39;原类名 新类名&#39;</code></p>
</blockquote>
</li>
</ol>
<h2 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a>H5自定义属性</h2><p>自定义属性目的：保存并使用数据，某些数据可以保存的页面中而不用存储到数据库里。<br>为了更容易判断某属性是内置属性还是自定义属性，H5新增了自定义属性，规定自定义属性要以<code>data-</code>开头。</p>
<h3 id="获取-H5新增方法"><a href="#获取-H5新增方法" class="headerlink" title="获取(H5新增方法)"></a>获取(H5新增方法)</h3><p><code>element.dataset.属性</code>或<code>element.dataset.[&#39;属性&#39;]</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div data-index=<span class="string">"2"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 获取自定义属性值</span></span><br><span class="line"><span class="regexp">console.log(div.dataset.index);</span></span><br><span class="line"><span class="regexp">console.log(div.dataset['index']);</span></span><br></pre></td></tr></table></figure>
<p><code>dataset</code>是一个集合，里面存放了所有以data开头的自定义属性<br>如果自定义属性里有多个<code>-</code>连接的单词，获取时采用驼峰命名法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div data-list-name=<span class="string">"andy"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 获取自定义属性值</span></span><br><span class="line"><span class="regexp">console.log(div.dataset.listName);</span></span><br><span class="line"><span class="regexp">console.log(div.dataset['listName']);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>​    H5新增的获取自定义属性的方法，只能获取data-开头的属性<br>​    IE 11以上才支持</p>
</blockquote>
<h2 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h2><p>若要同一组元素中的某一个元素实现某种样式，需要用到循环的排他思想算法</p>
<ol>
<li>所有元素全部清除样式</li>
<li>给当前元素设置样式<blockquote>
<p>注意顺序不能颠倒</p>
</blockquote>
</li>
</ol>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><p>网页中所有的内容都是节点（标签、属性、文本、注释等），用node表示。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>节点一般拥有三个基本属性：nodeType(节点类型)、nodeName(节点名称)、nodeValue(节点属性)</p>
<ul>
<li>元素节点nodeType为1</li>
<li>属性节点nodeType为2</li>
<li>文本节点nodeType为3（包括文字、空格、换行等）<br>节点操作主要操作的还是元素节点</li>
</ul>
<h3 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h3><ol>
<li><p>父级节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node.parentNode</span><br></pre></td></tr></table></figure>
<ul>
<li>返回指定节点最近的一个父节点</li>
<li>若没有父节点则返回null</li>
</ul>
</li>
<li><p>子节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parentNode.childNodes</span><br></pre></td></tr></table></figure>
<p>返回指定节点的子节点的集合，该集合为即时更新的集合</p>
<blockquote>
<p>注意：</p>
<p>​    返回值中包含了所有节(元素节点、文本节点等)，若只想获得元素节点，需要通过判断nodeType值进行选择，所以一般不提倡使用childNodes。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parentNode.children</span><br></pre></td></tr></table></figure>
<p>只读属性，返回所有元素子节点(只返回元素节点)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parentNode.firstChild  <span class="comment">// 返回第一个子节点，找不到返回null</span></span><br><span class="line">parentNode.lastChild   <span class="comment">// 返回最后一个子节点，找不到返回null</span></span><br></pre></td></tr></table></figure>
<p>都包含所有节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parentNode.firstElementChild  <span class="comment">// 返回第一个子元素节点，找不到返回null</span></span><br><span class="line">parentNode.lastElementChild   <span class="comment">// 返回最后一个子元素节点，找不到返回null</span></span><br></pre></td></tr></table></figure>
<p>IE9以上才支持</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parentNode.children[<span class="number">0</span>]  <span class="comment">// 返回第一个子元素节点，找不到返回null</span></span><br><span class="line">parentNode.children[parentNode.length - <span class="number">1</span>]  <span class="comment">// 返回第一个子元素节点，找不到返回null</span></span><br></pre></td></tr></table></figure>
<p>实际开发中用此写法</p>
</li>
<li><p>兄弟节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node.nextSibling  <span class="comment">// 返回指定元素下一个兄弟节点，找不到返回null</span></span><br><span class="line">node.previousSibling  <span class="comment">// 返回指定元素上一个兄弟节点，找不到返回null</span></span><br></pre></td></tr></table></figure>
<p>都包含所有节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node.nextElementSibling  <span class="comment">// 返回指定元素下一个兄弟元素节点</span></span><br><span class="line">node.previousElementSibling  <span class="comment">// 返回指定元素上一个兄弟元素节点</span></span><br></pre></td></tr></table></figure>
<p>IE9以上才支持<br>解决兼容性问题，封装一个兼容性的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNextElementSibling</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = element;</span><br><span class="line">    <span class="keyword">while</span> (el = el.nextSibling) &#123;</span><br><span class="line">        <span class="keyword">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.createElement(&#39;tagName&#39;)</span><br></pre></td></tr></table></figure>
<p>由于这些元素原本不存在，是根据需求动态生成的，所以称为动态创建元素节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.innerHTML &#x3D; &#39;&lt;div&gt;123&lt;&#x2F;div&gt;&#39;</span><br></pre></td></tr></table></figure>
<p>将内容写入节点，不会导致重绘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.write()  &#x2F;&#x2F; 很少使用</span><br></pre></td></tr></table></figure>
<p>直接将内容写入页面的内容流，但是文档流执行完毕，它会导致页面全部重绘</p>
<blockquote>
<p>区别：<br>    1. <code>document.write</code>会导致重绘，而<code>innerHTML</code>不会使页面重绘<br> 2. <code>innerHTML</code>创建多个元素效率更高(不使用拼接字符串，采用数组形式拼接)，结构稍微复杂<br> 3. <code>createElement</code>创建多个元素效率略低一些，但是结构更清晰</p>
</blockquote>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node.appendChild(child)</span><br></pre></td></tr></table></figure>
<p>将一个节点添加到指定节点的子节点列表末尾，<code>child</code>是子级，<code>node</code>是父级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node.insertBefore(child, 指定元素)</span><br></pre></td></tr></table></figure>
<p>将一个节点添加到指定节点的指定子节点前</p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node.removeChild(child)</span><br></pre></td></tr></table></figure>

<h3 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node.cloneNode()</span><br></pre></td></tr></table></figure>
<p>返回调用该方法的节点的副本，也称克隆节点或拷贝节点</p>
<blockquote>
<p>注意：<br>1.如果参数为空或者false，为浅拷贝，即只复制节点本身，不可隆其子节点<br>2.如果参数为true，为深拷贝，会复制节点本身及其所有子节点</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架</title>
    <url>/2020/03/16/Scrapy%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环境 Ubuntu 18.04.1 LTS</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>安装依赖（根据操作系统选择）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3 python3-dev python3-pip libxml2-dev libxslt1-dev zlib1g-dev libffi-dev libssl-dev</span><br></pre></td></tr></table></figure>

</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><p>在<a href="https://lwanting.github.io/2020/03/16/virtualenv/" target="_blank" rel="noopener">virtualenv</a>中安装<code>Scrapy</code>（防止与系统的包产生冲突）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>安装时遇到的问题</strong> </p>
<p>1） 读取超时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">raise ReadTimeoutError(self._pool, None, &quot;Read timed out.&quot;)</span><br><span class="line">pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host&#x3D;&#39;files.pythonhosted.org&#39;, port&#x3D;443): Read timed out.</span><br></pre></td></tr></table></figure>

<p>通过换源解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple scrapy</span><br></pre></td></tr></table></figure>

<p>2）报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR: Could not find a version that satisfies the requirement cryptography&gt;&#x3D;2.0 (from scrapy) (from versions: none)</span><br><span class="line">ERROR: No matching distribution found for cryptography&gt;&#x3D;2.0 (from scrapy)</span><br></pre></td></tr></table></figure>

<p>单独下载<code>cryptography</code>解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple cryptography</span><br></pre></td></tr></table></figure>

<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy startproject [项目名]</span><br></pre></td></tr></table></figure>

<h2 id="创建爬虫"><a href="#创建爬虫" class="headerlink" title="创建爬虫"></a>创建爬虫</h2><p>进入项目所在路径，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy genspider [爬虫名] [域名]</span><br></pre></td></tr></table></figure>

<p><strong>注意：爬虫名不能和项目名相同</strong> </p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ol>
<li>items.py：用来存放爬虫爬取下来得数据模型</li>
<li>middlewares.py：存放中间件文件</li>
<li>pipelines.py：将items得模型存储到本地磁盘中</li>
<li>settings.py：爬虫配置信息（如请求头，ip代理池等）</li>
<li>scrapy.cfg：项目的配置文件</li>
<li>spiders包：存放爬虫</li>
</ol>
<h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><ol>
<li><p>不遵守<code>robots.txt</code>协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROBOTSTXT_OBEY &#x3D; False</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置请求头，添加<code>User-Agent</code></p>
</li>
</ol>
<h2 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h2><p>进入环境，执行命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy crawl &lt;spider&gt;</span><br></pre></td></tr></table></figure>

<p>为了简化操作可以在项目下新建<code>start.py</code>文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> cmdline</span><br><span class="line"></span><br><span class="line">cmdline.execute([<span class="string">'scrapy'</span>, <span class="string">'crawl'</span>, <span class="string">'bsbdj'</span>])</span><br></pre></td></tr></table></figure>

<p>执行<code>start.py</code>文件即可运行爬虫</p>
]]></content>
      <categories>
        <category>Scrapy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualenv</title>
    <url>/2020/03/16/virtualenv/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>系统中不同项目可能需要不同版本的依赖，如A项目需使用Python2.7，而B项目需使用Python3.5，为了防止冲突，可为两个项目分别创建独立的运行环境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环境 Ubuntu 18.04.1 LTS</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>安装虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip3 install virtualenv</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装虚拟环境包装器，使用更加简洁的命令管理虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip3 install virtualenvwrapper</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Home/下的配置文件<code>.bashrc</code>，添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export WORKON_HOME&#x3D;$HOME&#x2F;.virtualenvs</span><br><span class="line">source &#x2F;usr&#x2F;local&#x2F;bin&#x2F;virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>

<p>使用<code>source .bashrc</code>命令使配置文件生效</p>
</li>
</ol>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ol>
<li><p>创建目录，并进入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir myproject</span><br><span class="line">cd myproject&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建独立的python环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkvirtualenv -p python3 虚拟环境名称</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p>退出虚拟环境命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<h2 id="查看与使用"><a href="#查看与使用" class="headerlink" title="查看与使用"></a>查看与使用</h2><p>查看所有虚拟环境命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workon 两次Tab键</span><br></pre></td></tr></table></figure>

<p>使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workon 虚拟环境名称</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除虚拟环境命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmvirtualenv 虚拟环境名称</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虚拟环境中使用<code>pip</code>命令安装Python包，但不可使用<code>sudo</code>命令，否则会装在全局环境下。</p>
<p>查看已安装的包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>virtualenv</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决IDM无法集成到Chrome上的问题</title>
    <url>/2020/02/29/%E8%A7%A3%E5%86%B3IDM%E6%97%A0%E6%B3%95%E9%9B%86%E6%88%90%E5%88%B0Chrome%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>下载并安装IDM后，Chrome上并未出现对应插件，尝试将IDM文件夹中<code>.crx</code>文件拖入扩展程序页面进行安装，提示“Chrome尝试对扩展程序进行降级处理”</p>
<a id="more"></a>

<p>解决方法如下：</p>
<ol>
<li>查看自己安装的IDM版本号，此处为6.36.5</li>
</ol>
<p><img src="https://i.loli.net/2020/02/29/o1LnVXTxMaCmbuw.png" alt="IDM版本号.png"></p>
<ol start="2">
<li><p>退出IDM，打开Chrome的配置文件</p>
<p><code>C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default\Secure Preferences</code></p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/02/29/o1LnVXTxMaCmbuw.png" alt="IDM版本号.png"></p>
<ol start="3">
<li><code>ctrl+f</code>搜索IDM，将下图两处版本号改为6.36，保存</li>
</ol>
<p><img src="https://i.loli.net/2020/02/29/4L2ouWAUxmgRqKb.png" alt="配置文件.png"></p>
<ol start="4">
<li>关闭Chrome，然后重新打开IDM和Chrome，插件已添加</li>
</ol>
<p>参考文章：<a href="https://blog.csdn.net/Perfect_Accepted/article/details/75021941" target="_blank" rel="noopener">https://blog.csdn.net/Perfect_Accepted/article/details/75021941</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo优化</title>
    <url>/2020/02/25/%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>  Hexo中有两个<code>_config.yml</code>配置文件，为了描述方便，称根目录下的配置文件为<code>站点配置文件</code>，主题目录下的配置文件为<code>主题配置文件</code><br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 版本信息</span><br><span class="line">Hexo v4.2.0</span><br><span class="line">NexT v7.7.1</span><br></pre></td></tr></table></figure><br>   <a id="more"></a></p>
<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p>修改<code>主题配置文件</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # 头像地址</span><br><span class="line">  url: &#x2F;images&#x2F;header.jpg</span><br><span class="line">  # 圆形显示</span><br><span class="line">  rounded: true</span><br><span class="line">  # 头像随鼠标旋转</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>


<h2 id="修改文章底部标签图标"><a href="#修改文章底部标签图标" class="headerlink" title="修改文章底部标签图标"></a>修改文章底部标签图标</h2><p>修改<code>主题配置文件</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 图标代替&#96;#&#96;</span><br><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure>

<h2 id="修改网站图标"><a href="#修改网站图标" class="headerlink" title="修改网站图标"></a>修改网站图标</h2><p>在<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里巴巴矢量图库</a>中下载16x16以及32x32规格的图标，存放在<code>\themes\next\source\images</code>下，<br>修改<code>主题配置文件</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;yourfavicon16x16.png    </span><br><span class="line">  medium: &#x2F;images&#x2F;yourfavicon32x32.png</span><br></pre></td></tr></table></figure>

<h2 id="修改页脚显示"><a href="#修改页脚显示" class="headerlink" title="修改页脚显示"></a>修改页脚显示</h2><p>修改<code>主题配置文件</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  since: 2020    # 建站年份</span><br><span class="line">  # 年份和版权信息间的图标</span><br><span class="line">  icon: </span><br><span class="line">    # 图标</span><br><span class="line">    name: heart</span><br><span class="line">    # 动画</span><br><span class="line">    animated: true</span><br><span class="line">    color: &quot;#ff0000&quot;</span><br><span class="line"></span><br><span class="line">  # 版权，默认站点配置文件中的&#96;author&#96;</span><br><span class="line">  copyright:</span><br><span class="line"></span><br><span class="line">  powered:</span><br><span class="line">    # 显示Powered by Hexo</span><br><span class="line">    enable: false</span><br><span class="line">    # Hexo版本信息</span><br><span class="line">    version: false</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # 主题信息</span><br><span class="line">    enable: false</span><br><span class="line">    # 主题版本信息</span><br><span class="line">    version: false</span><br><span class="line"></span><br><span class="line">  # ICP和公安备案信息</span><br><span class="line">  beian:</span><br><span class="line">    enable: false</span><br></pre></td></tr></table></figure>

<h2 id="配置RSS"><a href="#配置RSS" class="headerlink" title="配置RSS"></a>配置RSS</h2><ol>
<li>安装模块<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure></li>
<li>在<code>站点配置文件</code>中添加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin: hexo-generator-feed</span><br></pre></td></tr></table></figure></li>
<li>修改<code>主题配置文件</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">follow_me:</span><br><span class="line">  RSS: &#x2F;atom.xml || rss</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="代码块样式"><a href="#代码块样式" class="headerlink" title="代码块样式"></a>代码块样式</h2><p>修改<code>主题配置文件</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # 有以下主题可用</span><br><span class="line">  # normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  highlight_theme: night</span><br><span class="line">  # 增加复制键</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # 显示复制成功</span><br><span class="line">    show_result: true</span><br><span class="line">    # 代码块样式</span><br><span class="line">    style: mac</span><br></pre></td></tr></table></figure>
<h2 id="返回顶部"><a href="#返回顶部" class="headerlink" title="返回顶部"></a>返回顶部</h2><p>修改<code>主题配置文件</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # 侧边栏显示返回顶部</span><br><span class="line">  sidebar: false</span><br><span class="line">  # 进度百分比</span><br><span class="line">  scrollpercent: false</span><br></pre></td></tr></table></figure>

<h2 id="GitHub-Corners"><a href="#GitHub-Corners" class="headerlink" title="GitHub Corners"></a>GitHub Corners</h2><p>  方法一：<br>  修改<code>主题配置文件</code><br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github_banner:</span><br><span class="line">enable: true</span><br><span class="line">permalink: https:&#x2F;&#x2F;github.com&#x2F;yourname   #填写自己的github地址</span><br><span class="line">title: Follow me on GitHub</span><br></pre></td></tr></table></figure><br>  方法二：<br>  选择一个<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">样式</a><br>  找到<code>themes\next\layout\_layout.swig</code>文件,将样式代码复制到<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>下，并修改地址</p>
<h2 id="SE0设置"><a href="#SE0设置" class="headerlink" title="SE0设置"></a>SE0设置</h2><p>修改<code>主题配置文件</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 移动设备上禁用百度转换</span><br><span class="line">disable_baidu_transformation: true</span><br><span class="line"></span><br><span class="line"># 设置规范的链接</span><br><span class="line">canonical: false</span><br><span class="line"></span><br><span class="line"># 更改标题层次结构，有利于SEO优化</span><br><span class="line">seo: true</span><br><span class="line"></span><br><span class="line"># 主页显示副标题，需要现在站点配置文件配置副标题（subtitle: Subtitle）</span><br><span class="line">index_with_subtitle: true</span><br><span class="line"></span><br><span class="line"># Automatically add external URL with Base64 encrypt &amp; decrypt.</span><br><span class="line">exturl: false</span><br><span class="line"></span><br><span class="line"># 启用百度推送</span><br><span class="line">baidu_push: true</span><br></pre></td></tr></table></figure>

<h2 id="增加评论功能并显示阅读次数"><a href="#增加评论功能并显示阅读次数" class="headerlink" title="增加评论功能并显示阅读次数"></a>增加评论功能并显示阅读次数</h2><p>修改<code>主题配置文件</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Valine</span><br><span class="line"># For more information: https:&#x2F;&#x2F;valine.js.org, https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine</span><br><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid:   # Your leancloud application appid</span><br><span class="line">  appkey:  # Your leancloud application appkey</span><br><span class="line">  notify: false # 邮件提醒</span><br><span class="line">  verify: false # 验证码</span><br><span class="line">  placeholder: 请多指教~ # 评论框占位符</span><br><span class="line">  avatar: &quot;&quot; # 评论头像</span><br><span class="line">  guest_info: nick,mail # 评论可填写信息</span><br><span class="line">  pageSize: 10 # 每页显示评论数</span><br><span class="line">  language: # 语言</span><br><span class="line">  visitor: true # 文章阅读统计</span><br><span class="line">  comment_count: true # 评论数在主页和详细页面中都显示</span><br><span class="line">  recordIP: true # 记录评论者的ip</span><br></pre></td></tr></table></figure>

<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><ol>
<li>安装模块<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li>修改<code>主题配置文件</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # auto: 输入即搜索</span><br><span class="line">  # manual：按回车键或搜索键开始搜索</span><br><span class="line">  trigger: auto</span><br><span class="line">  # 显示每篇文章的前n个结果，若为-1则显示所有结果</span><br><span class="line">  top_n_per_article: 3</span><br><span class="line">  # 可搜索到html内容</span><br><span class="line">  unescape: true</span><br><span class="line">  # 加载页面时预加载搜索数据</span><br><span class="line">  preload: true</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h2><p>  在<code>themes\next\source\css\_common\components\post\post.styl</code>文件末尾添加：<br>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  // 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加动态模型"><a href="#添加动态模型" class="headerlink" title="添加动态模型"></a>添加动态模型</h2><p>安装模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<p>在<code>站点配置文件</code>中添加配置信息，具体信息可参考<a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" target="_blank" rel="noopener">live2d-widget.js API</a> 、<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">模型库</a> 、<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">预览</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F;</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-tororo  &#x2F;&#x2F;模型</span><br><span class="line">    scale: 1</span><br><span class="line">    hHeadPos: 0.5</span><br><span class="line">    vHeadPos: 0.618</span><br><span class="line">  display:</span><br><span class="line">    superSample: 2</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">    hOffset: 30</span><br><span class="line">    vOffset: -20</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">    scale: 0.5</span><br><span class="line">  react:</span><br><span class="line">    opacity: 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
