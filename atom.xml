<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千北</title>
  
  <subtitle>冲鸭</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-11T15:24:03.815Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>l-wanting</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue项目部署上线</title>
    <link href="http://yoursite.com/2021/05/11/Vue/Vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/"/>
    <id>http://yoursite.com/2021/05/11/Vue/Vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/</id>
    <published>2021-05-11T15:21:05.000Z</published>
    <updated>2021-05-11T15:24:03.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ol><li>阿里云服务器（CentOS）</li><li>域名解析</li><li><a href="https://www.netsarang.com/zh/xftp/" target="_blank" rel="noopener">Xftp</a>、<a href="https://www.netsarang.com/zh/xshell/" target="_blank" rel="noopener">Xshell</a></li><li>安装PM2</li><li>安装Nginx</li></ol><a id="more"></a><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名-解析-添加记录 ，由于只有一个域名且一级域名已经使用，所以这里使用二级域名。</p><p><a href="https://imgchr.com/i/0P3eIg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/26/0P3eIg.png" alt="0P3eIg.png"></a></p><p><a href="https://help.aliyun.com/knowledge_detail/29725.html?spm=a2c6h.13066369.0.0.c2121ac6YXFk1F&source=5176.11533457&userCode=ywqc0ubl&type=copy" target="_blank" rel="noopener">参考文档</a></p><h2 id="Vue项目打包"><a href="#Vue项目打包" class="headerlink" title="Vue项目打包"></a>Vue项目打包</h2><p>打包命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>打包完成后，项目的根目录下会生成一个 <code>dist</code> 文件夹，使用Xftp将<code>dist</code>文件上传到云服务器。</p><h2 id="配置PM2"><a href="#配置PM2" class="headerlink" title="配置PM2"></a>配置PM2</h2><p><a href="https://lwanting.github.io/2020/09/30/PM2/" target="_blank" rel="noopener">介绍及使用</a></p><p>将API项目上传至云服务器，使用PM2启动进程并保持在线。</p><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p><a href="https://lwanting.github.io/2020/09/30/Nginx/" target="_blank" rel="noopener">介绍及使用</a></p><p>在<code>/etc/nginx/conf.d/</code>目录下新建<code>music.conf</code>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen   80;</span><br><span class="line">    server_name  music.zwmuzhi.cn;</span><br><span class="line"></span><br><span class="line">    gzip on;   # 开启gzip</span><br><span class="line">    gzip_buffers 4 16k;  # 压缩所需缓冲区大小</span><br><span class="line">    gzip_comp_level 6;   # 压缩级别，数值越大压缩效果越好，效率越低</span><br><span class="line">    gzip_min_length 1k;  # 文件大于1k才压缩</span><br><span class="line">    gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;xml text&#x2F;javascript;   # 压缩的文件类型</span><br><span class="line">    gzip_vary on;   # 增加响应头Vary: Accept-Encoding</span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">    root   &#x2F;usr&#x2F;local&#x2F;vue-project&#x2F;music;   # vue项目的打包后的dist</span><br><span class="line">    index  index.html;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;api &#123;     # 当请求跨域时配置端口转发</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;;  # 后台服务地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>vue-router</code>有<code>hash</code>和<code>history</code>两种模式，不同的模式对应<code>nginx</code>的配置不同。<code>hash</code>模式下，上述配置即可，<code>history</code>模式下添加<code>try_files</code>。<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">参考文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">index  index.html;</span><br><span class="line">try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置后，重新加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>浏览器中可以通过二级域名成功访问项目即配置成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备工具&quot;&gt;&lt;a href=&quot;#准备工具&quot; class=&quot;headerlink&quot; title=&quot;准备工具&quot;&gt;&lt;/a&gt;准备工具&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;阿里云服务器（CentOS）&lt;/li&gt;
&lt;li&gt;域名解析&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.netsarang.com/zh/xftp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xftp&lt;/a&gt;、&lt;a href=&quot;https://www.netsarang.com/zh/xshell/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xshell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装PM2&lt;/li&gt;
&lt;li&gt;安装Nginx&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="部署" scheme="http://yoursite.com/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>code review技巧</title>
    <link href="http://yoursite.com/2021/04/18/code-review%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2021/04/18/code-review%E6%8A%80%E5%B7%A7/</id>
    <published>2021-04-18T13:19:48.000Z</published>
    <updated>2021-04-18T14:11:52.152Z</updated>
    
    <content type="html"><![CDATA[<p>1.pull request合入的目标分支是否正确。</p><p>2.若为bugfix。</p><ul><li>是否找到真正的root cause。</li><li>所采取的solution是什么，是否能真正解决该问题。</li><li>使用这种solution是否会导致新的问题，或是重现旧问题。<a id="more"></a></li><li>解决方法是否为最佳方法，是否存在其它更好的解决方法。</li><li>是否有边缘情况未考虑到。</li></ul><p>3.pull request中是否包含与当前任务无关的代码改动。</p><p>4.是否存在错别字、缩进、未删除调试代码或无用注释等低级错误。</p><p>5.是否存在重复代码或重复的模式。</p><p>6.命名是否符合规范。</p><ul><li>类名和对象名应是名词或名词短语</li><li>方法名应是动词或动词短语</li><li>做到见名知意</li><li>不要出现“自己造的缩写”</li></ul><p>7.若一次pull request改动过大，是否可以拆分为多次提交。</p><p>8.代码逻辑是否清楚，前后端分离。</p><p>9.是否存在执行效率较低、不符合阅读逻辑、不美观的写法。</p><p>10.函数是否符合规范。</p><ul><li>函数不应过长</li><li>函数参数最多尽量不要超过4个</li><li>分隔指令与询问（要么做什么事，要么回答什么事，二者不可得兼）</li></ul><p>11.对外部工具的调用是否有必要。</p><p>12.是否有用到不常用的系统接口、浏览器接口，接口兼容性如何。</p><p>13.代码改动是否会引发安全漏洞。</p><p>14.是否引入了不必要的数据库读写操作。</p><p>15.改动是否会让现有的行为失效。</p><p>16.是否编写了相对应的单元测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.pull request合入的目标分支是否正确。&lt;/p&gt;
&lt;p&gt;2.若为bugfix。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否找到真正的root cause。&lt;/li&gt;
&lt;li&gt;所采取的solution是什么，是否能真正解决该问题。&lt;/li&gt;
&lt;li&gt;使用这种solution是否会导致新的问题，或是重现旧问题。
    
    </summary>
    
    
      <category term="技术修养" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E4%BF%AE%E5%85%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>如何寻求技术支持</title>
    <link href="http://yoursite.com/2021/04/17/%E5%A6%82%E4%BD%95%E5%AF%BB%E6%B1%82%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/"/>
    <id>http://yoursite.com/2021/04/17/%E5%A6%82%E4%BD%95%E5%AF%BB%E6%B1%82%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/</id>
    <published>2021-04-17T14:26:15.000Z</published>
    <updated>2021-04-18T14:14:39.673Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，不可避免的会遇到一些自己无法解决的问题，需要寻求技术支持。通常会写邮件，或是使用github的issues等，提供充分的信息并合理地阐述有利于问题的快速解决。以下是我总结的寻求技术支持时需要注意的几点：</p><a id="more"></a><h3 id="简要的标题"><a href="#简要的标题" class="headerlink" title="简要的标题"></a>简要的标题</h3><p>标题简要的总结所遇到的问题，有助于对方在详细阅读前大致了解你的问题。不要不写标题或是写没有意义的东西，如“我遇到了一个问题，能不能帮帮我”。如果比较紧急，也可以在标题中突出紧急（不能只突出紧急）。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>1.正文中尽可能详细的描述所遇到的问题，会产生什么现象，是否有报错以及报错的详情。可以附上相关截图或是录屏，帮助对方更好的理解你遇到的问题。<br>2.分步骤描述如何复现该问题。<br>3.写出你有做过哪些尝试，以及得到的结果，并附上查到的资料。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>写出当前出现问题的环境，浏览器、操作系统以及各种工具的版本。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>避免出现大段的文字描述，大段文字并不会让人有看下去的欲望。注意条理性，语言简洁，分段分条说明。需要强调的地方可以加粗表示。</p><p>参考文章：<a href="https://www.renegade-empire.com/how-to-request-support-that-gets-solved-faster/" target="_blank" rel="noopener">https://www.renegade-empire.com/how-to-request-support-that-gets-solved-faster/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中，不可避免的会遇到一些自己无法解决的问题，需要寻求技术支持。通常会写邮件，或是使用github的issues等，提供充分的信息并合理地阐述有利于问题的快速解决。以下是我总结的寻求技术支持时需要注意的几点：&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术修养" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E4%BF%AE%E5%85%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端布局02-Flex布局</title>
    <link href="http://yoursite.com/2021/04/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%8002-Flex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2021/04/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%8002-Flex%E5%B8%83%E5%B1%80/</id>
    <published>2021-04-17T01:58:37.000Z</published>
    <updated>2021-04-17T02:02:07.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="与传统布局对比"><a href="#与传统布局对比" class="headerlink" title="与传统布局对比"></a>与传统布局对比</h3><p>传统布局：兼容性好、布局繁琐、有局限性(移动端表现不好)。</p><p>flex弹性布局：操作方便、布局简单、对PC端浏览器支持较差。</p><a id="more"></a><h3 id="布局原理"><a href="#布局原理" class="headerlink" title="布局原理"></a>布局原理</h3><p><img src="https://s1.ax1x.com/2020/07/21/UI7tdf.png" alt=""></p><p>Flex (Flexible Box)弹性布局，用来为盒模型提供最大的灵活性，任何一个容器都可以指定为Flex 布局。为父盒子设定Flex 布局后，子元素的<code>float</code>、<code>clear</code>、<code>vertical-align</code>属性都将失效。</p><p>采用Flex布局的元素，称为Flex 容器 (flex container)，简称“容器”。它所有的子元素自动称为容器成员，称为Flex 项目(flex item)，简称“项目”</p><p>总结：flex布局就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式。</p><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><p>注意： 主轴和侧轴是会发生改变的，<code>flex-direction</code>设置谁为主轴，剩下的就是侧轴，子元素跟随主轴排列。</p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。使用之前需要先确定好主轴。</p><ul><li><code>flex-start</code>（默认值）：从头部开始排列，若主轴是水平方向，则为左对齐。</li><li><code>flex-end</code>：从尾部开始排列，若主轴是水平方向，则为右对齐。</li><li><code>center</code>： 居中。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li></ul><h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义了如果一条轴线排不下，如何换行。</p><ul><li><code>nowrap</code>（默认值）：不换行，容器宽度不够时，会缩小项目宽度。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul><h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><p><code>align-items</code>属性定义项目在侧轴上如何对齐。在项目为单项（单行）是使用。</p><ul><li><code>flex-start</code>：侧轴的起点对齐。</li><li><code>flex-end</code>：侧轴的终点对齐。</li><li><code>center</code>：侧轴的中点对齐（居中）。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：拉伸，如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><ul><li><code>flex-start</code>：与侧轴的起点对齐。</li><li><code>flex-end</code>：与侧轴的终点对齐。</li><li><code>center</code>：与侧轴的中点对齐。</li><li><code>space-between</code>：与侧轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><blockquote><p><code>align-items</code>与<code>align-content</code>区别：<br><code>align-items</code>适用于单行情况下，只有上对齐、下对齐、居中和拉伸属性。<br><code>align-content</code>适用于多行(换行)的情况下，有上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</p></blockquote><h3 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p>flex属性定义项目分配剩余空间，用flex表示占几份，默认值为0。</p><h3 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性值：auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;h3 id=&quot;与传统布局对比&quot;&gt;&lt;a href=&quot;#与传统布局对比&quot; class=&quot;headerlink&quot; title=&quot;与传统布局对比&quot;&gt;&lt;/a&gt;与传统布局对比&lt;/h3&gt;&lt;p&gt;传统布局：兼容性好、布局繁琐、有局限性(移动端表现不好)。&lt;/p&gt;
&lt;p&gt;flex弹性布局：操作方便、布局简单、对PC端浏览器支持较差。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="移动端布局" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>VSCode Git History插件</title>
    <link href="http://yoursite.com/2020/12/06/VScode-Git-History%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/12/06/VScode-Git-History%E6%8F%92%E4%BB%B6/</id>
    <published>2020-12-06T14:47:22.000Z</published>
    <updated>2020-12-06T14:52:28.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Git History插件可以直观的查看相关文件的提交历史。</p><a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在VScode应用商店中搜索并下载。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>选中需要查看的文件，右键-&gt;Git: View File History。</p><p>View file content：仅浏览文件内容</p><p>Compare file with current workspace file：与当前工作区的文件对比</p><p>Compare file with previous commit：与上一次提交的文件对比</p><p>View file history：浏览文件的修改历史</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Git History插件可以直观的查看相关文件的提交历史。&lt;/p&gt;
    
    </summary>
    
    
      <category term="插件" scheme="http://yoursite.com/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="VS Code" scheme="http://yoursite.com/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://yoursite.com/2020/12/06/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/12/06/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-06T14:45:00.000Z</published>
    <updated>2021-04-15T15:58:39.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看修改内容"><a href="#查看修改内容" class="headerlink" title="查看修改内容"></a>查看修改内容</h2><p>查看文件修改的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff [file name]</span><br></pre></td></tr></table></figure><p>查看工作区和版本库里面最新版本的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD -- [file name]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>丢弃工作区修改的内容，回到最近一次<code>git add</code>或是<code>git commit</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- [file name]</span><br></pre></td></tr></table></figure><p>添加到暂存区后想丢弃修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD [file name]</span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul><li>用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [commit_id]</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm [file name]</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>如果误删，从版本库中恢复文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- [file name]</span><br></pre></td></tr></table></figure><h2 id="关联远程库"><a href="#关联远程库" class="headerlink" title="关联远程库"></a>关联远程库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path&#x2F;repo-name.git</span><br></pre></td></tr></table></figure><p>第一次推送master分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>之后推送master分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>查看所有分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>创建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [branch]</span><br></pre></td></tr></table></figure><p>切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branch]</span><br><span class="line">或</span><br><span class="line">git switch [branch]</span><br></pre></td></tr></table></figure><p>创建并切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [branch]</span><br><span class="line">或</span><br><span class="line">git switch -c [branch]</span><br></pre></td></tr></table></figure><p>删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [branch]</span><br><span class="line">git branch -D [branch]  &#x2F;&#x2F; 强行删除没有被合并过的分支</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>合并指定分支到当前分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure><p>git一般会使用<code>fast forward</code>模式合并，即修改指针完成合并，但是删除分之后无法查到合并记录，使用普通模式合并，合并后的历史可以查到合并记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; [branch]</span><br></pre></td></tr></table></figure><p>查看分支合并图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure><h3 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h3><p>一个分支上存在没有提交的文件，但需要转到另一个分支上处理时，保存现场</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>查看存储列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>恢复并删除<code>stash</code>内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;num&#125;   &#x2F;&#x2F; 恢复现场</span><br><span class="line">git stash drop stash@&#123;num&#125;    &#x2F;&#x2F; 删除现场</span><br><span class="line">或</span><br><span class="line">git stash pop  &#x2F;&#x2F; 弹出栈顶现场并删除</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br><code>stash</code>并不会保存<code>untracked file</code>，使用之前记得<code>git status</code>确认没有<code>untracked file</code>。<br>谨慎使用<code>stash</code>，可能会丢失修改。</p></blockquote><h3 id="复制提交"><a href="#复制提交" class="headerlink" title="复制提交"></a>复制提交</h3><p>在另一个分支上提交后，可以将此次提交复制到当前分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure><h3 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h3><p>查看远程库的详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>向远程库推送分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin [branch]</span><br></pre></td></tr></table></figure><p>创建远程的分支到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin&#x2F;[branch]</span><br></pre></td></tr></table></figure><p>远程分支领先于本地分支时，抓取远程的新提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to [branch] origin&#x2F;[branch]</span><br></pre></td></tr></table></figure><h3 id="拉取远端分支同时新建本地分支"><a href="#拉取远端分支同时新建本地分支" class="headerlink" title="拉取远端分支同时新建本地分支"></a>拉取远端分支同时新建本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gco --track origin&#x2F;bugfix</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要先进入到需要同步的分支</span><br><span class="line">git pull origin hotfix   &#x2F;&#x2F; 拉取远端分支</span><br><span class="line">&#x2F;&#x2F; 切换到冲突的分支</span><br><span class="line">git rebase hotfix   &#x2F;&#x2F; 整合分叉的分支</span><br><span class="line">&#x2F;&#x2F; 文件内修改冲突</span><br><span class="line">git add .  &#x2F;&#x2F; 将更改加入本地库</span><br><span class="line">git rebase --continue  </span><br><span class="line">&#x2F;&#x2F; 如果出现问题</span><br><span class="line">git rebase --skip</span><br><span class="line">git push xxx :[branch]   &#x2F;&#x2F; 删除远端分支</span><br><span class="line">git push xxx [branch]   &#x2F;&#x2F; 重新push</span><br></pre></td></tr></table></figure><p>rebase变基，即改变基本。</p><h2 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log  &#x2F;&#x2F; 查看提交历史</span><br><span class="line">git rebase -i [hash]  &#x2F;&#x2F; hash值对应最新一个想要保留的commit</span><br><span class="line">&#x2F;&#x2F; 编辑文件</span><br><span class="line">&#x2F;&#x2F; s表示该commit会合并到前一个commit</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><h2 id="本地库和远端库不同步"><a href="#本地库和远端库不同步" class="headerlink" title="本地库和远端库不同步"></a>本地库和远端库不同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log master..origin&#x2F;master  &#x2F;&#x2F; 比较本地与远端的差异</span><br><span class="line">git diff --start master origin&#x2F;master  &#x2F;&#x2F; 统计文件的改动</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 记录commit码</span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin&#x2F;hotfix</span><br><span class="line">&#x2F;&#x2F; 进入新的分支</span><br><span class="line">git cherry-pick [commit码]</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin hotfix</span><br><span class="line">gir rebase origin&#x2F;hotfix</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><h2 id="查看文件修改情况"><a href="#查看文件修改情况" class="headerlink" title="查看文件修改情况"></a>查看文件修改情况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git blame [文件路径]</span><br><span class="line">git show [commit码]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查看修改内容&quot;&gt;&lt;a href=&quot;#查看修改内容&quot; class=&quot;headerlink&quot; title=&quot;查看修改内容&quot;&gt;&lt;/a&gt;查看修改内容&lt;/h2&gt;&lt;p&gt;查看文件修改的内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git diff [file name]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;查看工作区和版本库里面最新版本的区别&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git diff HEAD -- [file name]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>PM2</title>
    <link href="http://yoursite.com/2020/09/30/PM2/"/>
    <id>http://yoursite.com/2020/09/30/PM2/</id>
    <published>2020-09-30T09:42:36.000Z</published>
    <updated>2020-09-30T09:44:01.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PM2是node进程管理工具，它可以管理和保持应用程序在线，支持性能监控，进程守护，负载均衡等功能。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>PM2依赖node和npm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装pm2</span><br><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>启动进程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>--watch</code>：监听应用目录的变化，一旦发生变化，自动重启。</li><li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果<code>-i 0</code>或者<code>-i max</code>，则根据当前机器核数确定实例数目。</li><li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如<code>--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</code></li><li><code>-n --name</code>：应用的名称。查看应用信息的时候可以用到。</li><li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径。</li><li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径。</li></ul><p><strong>重启进程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重启指定名称或id的进程</span><br><span class="line">pm2 restart [name or id]</span><br><span class="line">&#x2F;&#x2F; 重启所有进程</span><br><span class="line">pm2 restart all</span><br></pre></td></tr></table></figure><p><strong>停止进程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 停止指定名称或id的进程</span><br><span class="line">$ pm2 stop [name or id]</span><br><span class="line">&#x2F;&#x2F; 停止所有进程</span><br><span class="line">$ pm2 stop all</span><br></pre></td></tr></table></figure><p><strong>杀死进程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 杀死指定名称或id的进程</span><br><span class="line">$ pm2 delete [name or id]</span><br><span class="line">&#x2F;&#x2F; 杀死所有进程</span><br><span class="line">$ pm2 delete all</span><br></pre></td></tr></table></figure><p><strong>查看所有启动的进程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 list</span><br></pre></td></tr></table></figure><p><strong>查看进程日志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看指定名称或id的进程的日志</span><br><span class="line">pm2 logs [name or id]</span><br><span class="line">&#x2F;&#x2F; 查看所有进程的日志</span><br><span class="line">pm2 logs all</span><br></pre></td></tr></table></figure><p><strong>开机自动启动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 startup</span><br></pre></td></tr></table></figure><p>将生成的开机自启动命令粘贴到控制台执行并保存设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 save</span><br></pre></td></tr></table></figure><p>参考资料：</p><ol><li><a href="https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/</a></li><li><a href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/p/pm2-documentation.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;PM2是node进程管理工具，它可以管理和保持应用程序在线，支持性能监控，进程守护，负载均衡等功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
    
      <category term="PM2" scheme="http://yoursite.com/tags/PM2/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://yoursite.com/2020/09/30/Nginx/"/>
    <id>http://yoursite.com/2020/09/30/Nginx/</id>
    <published>2020-09-30T09:37:42.000Z</published>
    <updated>2021-04-17T02:04:42.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Nginx是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like协议下发行，可以在UNIX、GNU/Linux、BSD、Mac OS X、Solaris，以及Microsoft Windows等操作系统中运行。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载nginx-1.18.0.tar.gz 安装包，将其放在root⽬录下。</p><p>1、安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install  pcre pcre-devel -y </span><br><span class="line">yum install openssl openssl-devel -y</span><br></pre></td></tr></table></figure><p>2、将Nginx安装包解压到 <code>/usr</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf &#x2F;root&#x2F;nginx-1.18.0.tar.gz -C .&#x2F;</span><br></pre></td></tr></table></figure><p>3、编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.18.0&#x2F;</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure><p>其他命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload            # 重新载入配置文件，不重启进程，不会停止处理请求</span><br><span class="line">nginx -s stop              # 停止 Nginx</span><br><span class="line">nginx -t                   # 检查配置文件语法</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>主配置文件<code>/etc/nginx/nginx.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1; # 设置值和CPU核心数一致</span><br><span class="line"></span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;  # 错误日志</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;  # nginx守护进程的pid文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;  # 每个进程能够接受的最大连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main; # 自定义服务日至</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; # 配置文件的引入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一台服务器配置多个网站，如果配置都写在主配置文件中，会导致主配置文件体积变大，可读性降低。所以需要分离配置文件，<code>include /etc/nginx/conf.d/*.conf;</code>表示引入了<code>/etc/nginx/conf.d/</code>下所有以<code>.conf</code>文件结尾的文件，该目录下的配置文件只需要有<code>server</code>级。</p><p>参考资料：<a href="https://www.jianshu.com/p/d8bd75c0fb1b" target="_blank" rel="noopener">https://www.jianshu.com/p/d8bd75c0fb1b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Nginx是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like协议下发行，可以在UNIX、GNU/Linux、BSD、Mac OS X、Solaris，以及Microsoft Windows等操作系统中运行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>good-storage插件</title>
    <link href="http://yoursite.com/2020/09/25/good-storage%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/09/25/good-storage%E6%8F%92%E4%BB%B6/</id>
    <published>2020-09-25T13:24:21.000Z</published>
    <updated>2020-09-25T13:28:38.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用<code>good-storge</code>插件在缓存中读写数据，因为原生的<code>localStorage</code>中的键值对总是以字符串的形式存储，存储数组时需要进行频繁的格式转换。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install good-storage</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import storage from &#39;good-storage&#39;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localStorage</span></span><br><span class="line">storage.set(key,val) </span><br><span class="line">storage.get(key, def)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// sessionStorage</span></span><br><span class="line">storage.session.set(key, val)</span><br><span class="line">storage.session.get(key, val)</span><br></pre></td></tr></table></figure><p>API：</p><ol><li><p><code>set(key, val)</code></p><p>以键值对的形式存储。</p></li><li><p><code>get(key, def)</code></p><p>用键获取值，若没有找到，则赋值为def。</p></li><li><p><code>remove(key)</code></p><p>移除键对应的存储记录。</p></li></ol><p><a href="https://www.npmjs.com/package/good-storage" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;good-storge&lt;/code&gt;插件在缓存中读写数据，因为原生的&lt;code&gt;localStorage&lt;/code&gt;中的键值对总是以字符串的形式存储，存储数组时需要进行频繁的格式转换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="插件" scheme="http://yoursite.com/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="storge" scheme="http://yoursite.com/tags/storge/"/>
    
  </entry>
  
  <entry>
    <title>全屏插件screenfull.js</title>
    <link href="http://yoursite.com/2020/09/25/%E5%85%A8%E5%B1%8F%E6%8F%92%E4%BB%B6screenfull-js/"/>
    <id>http://yoursite.com/2020/09/25/%E5%85%A8%E5%B1%8F%E6%8F%92%E4%BB%B6screenfull-js/</id>
    <published>2020-09-25T13:23:33.000Z</published>
    <updated>2020-09-25T13:28:33.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>screenfull.js是用于跨浏览器使用JavaScript <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fullscreen_API" target="_blank" rel="noopener">Fullscreen API</a>的简单包装器，可让将页面或任何元素全屏显示，并且平滑浏览器实现差异。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install screenfull --save</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import screenfull from &#39;screenfull&#39;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>方法：</p><ol><li><p><code>.request()</code></p><p>使元素全屏显示，默认为<code>&lt;html&gt;</code>。</p></li><li><p><code>.exit()</code></p><p>退出全屏。</p></li><li><p><code>.toggle()</code></p><p>当前处于全屏状态则退出全屏，否则，全屏显示。</p></li></ol><p>属性：</p><ol><li><p><code>.isFullscreen</code></p><p>返回布尔值，表示当前是否处于全屏状态。</p></li><li><p><code>.element</code></p><p>返回当前全屏的元素，若无则返回null。</p></li><li><p><code>.isEnabled</code></p><p>返回布尔值，表示是否允许全屏。如果页面处于<code>&lt;iframe&gt;</code>标签内，则需要添加<code>allowfullscreen</code>属性。</p></li></ol><p><a href="https://github.com/sindresorhus/screenfull.js/" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;screenfull.js是用于跨浏览器使用JavaScript &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Fullscreen_API&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fullscreen API&lt;/a&gt;的简单包装器，可让将页面或任何元素全屏显示，并且平滑浏览器实现差异。&lt;/p&gt;
    
    </summary>
    
    
      <category term="插件" scheme="http://yoursite.com/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>时间处理插件Moment.js</title>
    <link href="http://yoursite.com/2020/09/25/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E6%8F%92%E4%BB%B6Moment-js/"/>
    <id>http://yoursite.com/2020/09/25/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E6%8F%92%E4%BB%B6Moment-js/</id>
    <published>2020-09-25T13:16:58.000Z</published>
    <updated>2020-09-25T13:28:29.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Moment.js是一个简单易用的轻量级JavaScript日期处理类库，提供了日期格式化、日期解析等功能。它支持在浏览器和NodeJS两种环境中运行。此类库能够将给定的任意日期转换成多种不同的格式，具有强大的日期计算功能，同时也内置了能显示多样的日期形式的函数。Moment.js支持多种语言。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install moment --save</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import moment from &#39;moment&#39;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>组件内使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = moment().format()</span><br></pre></td></tr></table></figure></li><li><p>在过滤器中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'formatDate'</span>, (date, pattern = <span class="string">'YYYY-MM-DD HH:mm:ss'</span>) =&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> moment(date).format(pattern)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; time | formatDate(<span class="string">'YYYY-MM-DD'</span>) &#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><p><a href="http://momentjs.cn/docs/" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Moment.js是一个简单易用的轻量级JavaScript日期处理类库，提供了日期格式化、日期解析等功能。它支持在浏览器和NodeJS两种环境中运行。此类库能够将给定的任意日期转换成多种不同的格式，具有强大的日期计算功能，同时也内置了能显示多样的日期形式的函数。Moment.js支持多种语言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="插件" scheme="http://yoursite.com/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript笔记05-补充</title>
    <link href="http://yoursite.com/2020/08/12/JavaScript%E7%AC%94%E8%AE%B005-%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2020/08/12/JavaScript%E7%AC%94%E8%AE%B005-%E8%A1%A5%E5%85%85/</id>
    <published>2020-08-12T13:46:12.000Z</published>
    <updated>2020-08-12T13:56:14.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><p>创建对象有三种方法：</p><ul><li>对象字面量</li><li>new Object()</li><li>自定义构造函数</li></ul><a id="more"></a><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值。可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里。</p><ul><li>构造函数用于创建某一类对象，首字母要大写</li><li>构造函数要和<code>new</code>一起使用才有意义</li></ul><p><code>new</code>的执行过程：</p><ul><li>在内存中创建一个空对象。</li><li>让<code>this</code>指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面不需要<code>return</code>）。</li></ul><p>构造函数的<strong>成员</strong>：</p><ul><li>静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问 。</li><li>实例成员：在构造函数内部通过<code>this</code>创建的对象成员称为实例成员，只能由实例化的对象来访问。</li></ul><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>构造函数给每个实例对象都开辟了一个独立的内存空间，会存在浪费内存的问题。</p><p>JavaScript 规定，每一个构造函数都有一个<code>prototype</code>属性,这个<code>prototype</code>是一个对象，该对象的所有属性和方法，都会被构造函数所拥有。把那些不变的方法直接定义在<code>prototype</code>对象上，这样所有对象的实例就都可以共享这些方法。</p><p><strong>扩展内置对象</strong></p><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p><blockquote><p>注意：</p><p>数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p></blockquote><h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 _proto_"></a>对象原型 _<em>proto_</em></h3><p>对象都会有一个属性<code>__proto__</code>指向构造函数的<code>prototype</code>原型对象，对象可以使用构造函数<code>prototype</code>原型对象的属性和方法，就是因为对象有<code>__proto__</code>原型的存在。</p><ul><li><code>__proto__</code>对象原型和原型对象<code>prototype</code>是等价的</li><li><code>__proto__</code>对象原型的意义在于为对象的查找机制提供一个方向，但它是一个非标准属性，实际开发中不可以使用这个属性，只是内部指向原型对象<code>prototype</code>。</li></ul><p><strong>成员查找机制</strong></p><ul><li>访问一个对象的属性或方法时，首先查找这个对象自身有没有该属性。</li><li>如果没有就查找它的原型，也就是 <code>__proto__</code>指向的<code>prototype</code>原型对象。</li><li>如果还没有就查找原型对象的原型。</li><li>依此类推一直找到 Object 为止（null）。</li></ul><h3 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h3><p>对象原型<code>__proto__</code>和构造函数原型对象<code>prototype</code>里都有一个<code>constructor</code>属性，称为构造函数，它指向构造函数本身。</p><p><code>constructor</code>主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p><p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，可以给原型对象采取<strong>对象形式</strong>赋值，这样就会<strong>覆盖</strong>构造函数原型对象原来的内容，而修改后的原型对象<code>constructor</code>就不再指向当前构造函数了。此时，需要在修改后的原型对象中，添加一个<code>constructor</code>指向原来的构造函数。</p><h3 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h3><img src="https://s1.ax1x.com/2020/08/07/aWG0nP.png" style="zoom:50%; margin-left:0;" /><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><img src="https://s1.ax1x.com/2020/08/07/aWtsAK.png" style="zoom:50%; margin-left:0;" /><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过构造函数+原型对象模拟实现继承，称为组合继承。</p><p><strong>call()</strong></p><p><code>call()</code>调用函数, 并且修改函数运行时的<code>this</code>指向   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thisArg ：当前调用函数 this 的指向对象</span></span><br><span class="line"><span class="comment">// arg1，arg2：传递的其他参数</span></span><br><span class="line">func.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>通过<code>call()</code>把父类型的<code>this</code>指向子类型的<code>this</code>，这样就可以实现子类型继承父类型的属性。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此时父类的 this 指向子类的 this，同时调用这个函数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age, sex);</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">'zs'</span>, <span class="number">18</span>, <span class="string">'男'</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p><strong>组合继承</strong></p><ul><li>让子类的原型对象<code>prototype = new 父类()</code> </li><li>子类原型对象指向父类的实例对象，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</li><li>由于以对象形式修改了子类原型对象，所以需要将子类的<code>constructor</code>重新指向子类的构造函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">100000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>, uname, age);</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype;  直接赋值若修改了子原型对象,父原型对象也会跟着一起变化</span></span><br><span class="line"><span class="comment">// 子类原型对象指向父类的实例对象</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 使用 constructor 指回原来的构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'zs'</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><strong>寄生组合继承</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">100000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>, uname, age);</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype;  直接赋值若修改了子原型对象,父原型对象也会跟着一起变化</span></span><br><span class="line"><span class="comment">// 子类原型对象指向父类的实例对象</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line"><span class="comment">// 使用 constructor 指回原来的构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'zs'</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>组合继承和寄生组合继承的<strong>区别</strong>：</p><ul><li>组合继承在将子类原型对象指向父类实例后，子类原型对象中也拥有了父类的属性，此时子类实例和原型对象中都拥有<code>uname</code>和<code>age</code>属性，如果删除实力上的<code>uname</code>属性，实际上还能访问到原型上的属性。</li><li>寄生组合继承中<code>Object.create(Father.prototype)</code>返回一个以<code>Father.prototype</code>为原型的对象，不执行<code>Father</code>方法，所以子类原型对象中不会存在<code>uname</code>和<code>age</code>属性。</li><li>寄生组合继承比组合继承更合理。</li></ul><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[, index, arr]</span>))</span></span><br></pre></td></tr></table></figure><ul><li>currentValue：数组当前项的值</li><li>index：数组当前项的索引</li><li>arr：数组对象本身</li></ul><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[,index,arr]</span>))</span></span><br></pre></td></tr></table></figure><ul><li>currentValue：数组当前项的值</li><li>index：数组当前项的索引</li><li>arr：数组对象本身</li></ul><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><blockquote><p>注意：map() 不会对空数组进行检测且不会改变原始数组。</p></blockquote><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[, index, arr]</span>))</span></span><br></pre></td></tr></table></figure><ul><li>currentValue: 数组当前项的值</li><li>index：数组当前项的索引</li><li>arr：数组对象本身</li></ul><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组。</p><blockquote><p>注意：filter() 方法直接返回一个新数组。 </p></blockquote><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[, index, arr]</span>))</span></span><br></pre></td></tr></table></figure><ul><li>currentValue: 数组当前项的值</li><li>index：数组当前项的索引</li><li>arr：数组对象本身</li></ul><p>some() 方法用于检测数组中的元素是否满足指定条件，即查找数组中是否有满足条件的元素。</p><blockquote><p>注意:</p><p>some() 方法返回值是布尔值，如果查找到这个元素，就返回true，否则返回false。</p><p>找到第一个满足条件的元素就终止循环，不再继续查找。</p></blockquote><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue[, index, arr]</span>))</span></span><br></pre></td></tr></table></figure><ul><li>currentValue: 数组当前项的值</li><li>index：数组当前项的索引</li><li>arr：数组对象本身</li></ul><p>every() 方法用于检测用于检测数组所有元素是否都符合指定条件。</p><blockquote><p>注意：</p><p>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</p><p>若所有元素都满足条件，则返回 true。</p></blockquote><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br></pre></td></tr></table></figure><p>Object.keys()方法用于获取对象自身所有的属性。效果类似<code>for…in</code>，返回一个由属性名组成的<strong>数组</strong>。</p><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><ul><li>obj：必需。要定义属性的对象。    </li><li>prop：必需。需定义或修改的属性的名字</li><li>descriptor：必需。目标属性所拥有的特性， 以对象形式<code>{ }</code>书写<ul><li>value: 设置属性的值  默认为undefined</li><li>writable: 值是否可以重写。true | false  默认为false</li><li>enumerable: 目标属性是否可以被枚举。true | false 默认为 false</li><li>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false  默认为false</li></ul></li></ul><h2 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><ol><li><p>函数声明方式<code>function</code>关键字 (命名函数)</p></li><li><p>函数表达式 (匿名函数)</p></li><li><p>new Function()，Function里的参数都必须是字符串格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'参数1'</span>,<span class="string">'参数2'</span>..., <span class="string">'函数体'</span>)</span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li>第三种方式执行效率低，也不方便书写，因此较少使用</li><li>所有函数都是Function的实例</li><li>函数也属于对象</li></ul><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><ol><li><p>普通函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line">fn.call();</span><br></pre></td></tr></table></figure></li><li><p>对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.fn();</span><br></pre></td></tr></table></figure></li><li><p>构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Obj()</span><br></pre></td></tr></table></figure></li><li><p>绑定事件函数</p><p>执行相应操作。</p></li><li><p>定时器函数</p><p>定时器自动调用。</p></li><li><p>立即执行函数</p><p>自动调用。</p></li></ol><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><table><thead><tr><th>调用方式</th><th>this指向</th></tr></thead><tbody><tr><td>普通函数</td><td>window</td></tr><tr><td>对象的方法</td><td>该方法所属对象</td></tr><tr><td>构造函数</td><td>实例对象，原型对象里的方法也指向实例对象</td></tr><tr><td>绑定事件函数</td><td>绑定事件对象</td></tr><tr><td>定时器函数</td><td>window</td></tr><tr><td>立即执行函数</td><td>window</td></tr></tbody></table><h3 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h3><p><strong>call()方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thisArg：在 fun 函数运行时指定的 this 值</span></span><br><span class="line"><span class="comment">// arg1，arg2：传递的其他参数</span></span><br><span class="line">func.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p><code>call()</code>方法参数为空时仅调用函数，指明参数可以改变函数内<code>this</code>的指向，主要用于实现继承。</p><p><strong>apply()方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thisArg：在fun函数运行时指定的 this 值</span></span><br><span class="line"><span class="comment">// argsArray：传递的值，必须包含在数组里面</span></span><br><span class="line">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure><p><code>apply()</code>方法参数为空时仅调用函数，指明参数可以改变函数内<code>this</code>的指向，可以利用<code>apply()</code>借助数学内置对象求数组的最大最小值。</p><blockquote><p>注意：第二个参数必须为数组</p></blockquote><p><strong>bind()方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thisArg：在 fun 函数运行时指定的 this 值</span></span><br><span class="line"><span class="comment">// arg1，arg2：传递的其他参数</span></span><br><span class="line">func.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p><code>bind()</code>方法不调用函数，返回一个<strong>原函数的拷贝</strong>，并拥有指定的 <code>this</code>值和初始参数。只想改变<code>this</code>指向，并不想调用这个函数的时候，可以使用<code>bind()</code>，如改变定时器内部<code>this</code>指向。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES5的严格模式是采用具有限制性JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。</p><ul><li>消除Javascript语法的一些不合理、不严谨之处，减少了一些怪异行为。</li><li>消除代码运行的一些不安全之处，保证代码运行的安全。</li><li>提高编译器效率，增加运行速度。</li><li>禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字：class, enum, export, extends, import, super 不能做变量名。</li></ul><h3 id="调用严格模式"><a href="#调用严格模式" class="headerlink" title="调用严格模式"></a>调用严格模式</h3><p>严格模式可以应用到整个脚本或个别函数中。</p><p><strong>为脚本开启严格模式</strong>：</p><p>为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句 <code>&quot;use strict&quot;;</code> 或 <code>&#39;use strict&#39;;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> v = <span class="string">"strict mode"</span>;</span><br></pre></td></tr></table></figure><p><strong>为函数开启严格模式</strong>：</p><p>要给某个函数开启严格模式，需要把<code>&quot;use strict&quot;;</code> 或 <code>&#39;use strict&#39;;</code>声明放在函数体所有语句之前。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"strict mode"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notStrict</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="string">"not strict mode"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="严格模式中的变化"><a href="#严格模式中的变化" class="headerlink" title="严格模式中的变化"></a>严格模式中的变化</h3><p><strong>1.变量</strong></p><ul><li>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式中变量都必须<strong>先声明再使用</strong>。</li><li>严禁删除已经声明的变量。</li></ul><p><strong>2.this 指向</strong></p><ul><li>严格模式下全局作用域里函数中的<code>this</code>为<code>undefined</code>。</li><li>严格模式下，构造函数必须用<code>new</code>调用。</li><li><code>new</code>实例化的构造函数还是指向创建的对象实例。</li><li>定时器<code>this</code>还是指向 window 。</li><li>事件、对象还是指向调用者。</li></ul><p><strong>3.函数</strong></p><ul><li>函数不能有重名的参数。</li><li>函数必须声明在顶层。为了与新版本ES6接轨，不允许在非函数的代码块内 (如<code>for</code>,<code>if</code>) 声明函数。 </li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包（closure）指有权访问另一个函数作用域中变量的<strong>函数</strong>，即外部作用域可以访问一个函数内的局部变量。 换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p><p>闭包作用：延伸变量的作用范围。</p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p><strong>浅拷贝</strong>只是拷贝一层, 更深层次对象级别的只拷贝引用。</p><p><strong>深拷贝</strong>拷贝多层, 每一级别的数据都会拷贝。</p><p>实现浅拷贝方法：</p><ol><li><p><code>for···in</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'zs'</span>,</span><br><span class="line">    msg: &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    o[k] = obj[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ES6新增<code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure></li></ol><p>实现深拷贝方法：</p><ol><li><p>递归拷贝每一层数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'zs'</span>,</span><br><span class="line">    msg: &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    hobbies: [<span class="string">'sing'</span>, <span class="string">'dance'</span>, <span class="string">'rap'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 封装函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">newObj, oldObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> oldobj) &#123;</span><br><span class="line">        <span class="comment">// 判断属性值属于那种数据类型</span></span><br><span class="line">        <span class="comment">// 1. 获取属性值  oldobj[k]</span></span><br><span class="line">        <span class="keyword">var</span> item = oldobj[k];</span><br><span class="line">        <span class="comment">// 2. 判断是否为数组</span></span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            newobj[k] = [];</span><br><span class="line">            deepCopy(newobj[k], item)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 判断是否为对象</span></span><br><span class="line">            newobj[k] = &#123;&#125;;</span><br><span class="line">            deepCopy(newobj[k], item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 简单数据类型</span></span><br><span class="line">            newobj[k] = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">deepCopy(o, obj);</span><br></pre></td></tr></table></figure></li><li><p>JSON对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br></pre></td></tr></table></figure></li><li><p>jQuery的extend方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deep: Boolean类型 是否深度合并对象，默认为false。</span></span><br><span class="line"><span class="comment">// target: 目标对象，其他对象的成员属性将被附加到该对象上。</span></span><br><span class="line"><span class="comment">// object: 被合并对象</span></span><br><span class="line">$.extend( [deep ], target, object1 [, objectN ] )</span><br></pre></td></tr></table></figure></li><li><p>lodash函数库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = _.cloneDeep(oldObj)</span><br></pre></td></tr></table></figure></li></ol><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>通过调用RegExp对象的构造函数创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/表达式/</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过字面量创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/表达式/</span>;</span><br></pre></td></tr></table></figure></li></ol><p><code>test()</code>方法用于检测字符串是否符合该规则，返回值为布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/表达式/</span>; </span><br><span class="line">reg.test(str)</span><br></pre></td></tr></table></figure><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th align="center">特殊字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">^</td><td align="left">匹配输入字符串的开始位置，当该符号在方括号表达式中使用时，表示取反。</td></tr><tr><td align="center">$</td><td align="left">匹配输入字符串的结尾位置</td></tr><tr><td align="center">*</td><td align="left">匹配前面的子表达式零次或多次（大于等于0）</td></tr><tr><td align="center">+</td><td align="left">匹配前面的子表达式一次或多次（大于等于1）</td></tr><tr><td align="center">?</td><td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。（0 | 1）</td></tr><tr><td align="center">.</td><td align="left">匹配除换行符 \n 之外的任何单字符</td></tr><tr><td align="center">{n}</td><td align="left">匹配n次</td></tr><tr><td align="center">{n,}</td><td align="left">匹配n次或多次</td></tr><tr><td align="center">{n,m}</td><td align="left">匹配n到m次</td></tr><tr><td align="center">|</td><td align="left">指明两项之间的一个选择（或选项）</td></tr></tbody></table><p>括号：</p><ul><li>大括号 量词符。表示重复次数</li><li>中括号 字符集合。匹配中括号中的任意字符，根据特殊字符决定匹配次数。</li><li>小括号 表示优先级，括号内的子表达式可以获取供以后使用。</li></ul><blockquote><p>注意：特殊字符匹配本身时，需要使用<code>\</code>进行转义。</p></blockquote><table><thead><tr><th align="center">预定义类</th><th>描述</th></tr></thead><tbody><tr><td align="center">\d</td><td>匹配一个数字字符。等价于 [0-9]</td></tr><tr><td align="center">\D</td><td>匹配一个非数字字符。等价于 [^0-9]</td></tr><tr><td align="center">\w</td><td>匹配字母、数字、下划线。等价于[A-Za-z0-9_]</td></tr><tr><td align="center">\W</td><td>匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]</td></tr><tr><td align="center">\s</td><td>匹配空白字符，包括空格、制表符、换页符等。等价于 [ \f\n\r\t\v]</td></tr><tr><td align="center">\S</td><td>匹配非空白字符。等价于 [^ \f\n\r\t\v]</td></tr></tbody></table><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>replace()</code> 方法可以实现替换字符串操作，替换的参数可以是字符串或正则表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.replace(regexp/substr,replacement)</span><br></pre></td></tr></table></figure><p>返回值是替换完毕的新字符串。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/表达式/[<span class="keyword">switch</span>]</span><br></pre></td></tr></table></figure><ul><li>g：全局匹配 </li><li>i：忽略大小写 </li><li>gi：全局匹配 + 忽略大小写</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;构造函数和原型&quot;&gt;&lt;a href=&quot;#构造函数和原型&quot; class=&quot;headerlink&quot; title=&quot;构造函数和原型&quot;&gt;&lt;/a&gt;构造函数和原型&lt;/h2&gt;&lt;p&gt;创建对象有三种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象字面量&lt;/li&gt;
&lt;li&gt;new Object()&lt;/li&gt;
&lt;li&gt;自定义构造函数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题记录</title>
    <link href="http://yoursite.com/2020/08/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/08/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-08-07T14:52:30.000Z</published>
    <updated>2020-09-02T15:42:27.918Z</updated>
    
    <content type="html"><![CDATA[<p>记录面试过程中被问到的知识点</p><a id="more"></a><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>1、状态码</p><ul><li>1XX：信息状态码</li><li>2XX：成功状态码<ul><li><code>200 OK</code> 正常返回信息</li><li><code>201 Created</code> 请求成功并且服务器创建了新的资源</li><li><code>202 Accepted</code> 服务器已接受请求，但尚未处理</li></ul></li><li>3XX：重定向<ul><li><code>301 Moved Permanently</code> 请求的网页已永久移动到新位置。</li><li><code>302 Found</code> 临时性重定向。</li><li><code>303 See Other</code> 临时性重定向，且总是使用 <code>GET</code> 请求新的 <code>URL</code>。</li><li><code>304 Not Modified</code> 自从上次请求后，请求的网页未修改过。</li></ul></li><li>4XX：客户端错误<ul><li><code>400 Bad Request</code> 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li><li><code>401 Unauthorized</code> 请求未授权。</li><li><code>403 Forbidden</code> 禁止访问。</li><li><code>404 Not Found</code> 找不到如何与 `URL 相匹配的资源。</li></ul></li><li>5XX：服务器错误<ul><li><code>500 Internal Server Error</code> 最常见的服务器端错误。</li><li><code>503 Service Unavailable</code> 服务器端暂时无法处理请求（可能过载或维护）。</li></ul></li></ul><p>2、网站性能优化</p><ul><li>减少http请求次数：精灵图，JS、CSS源码压缩、控制图片大小，CDN托管，data缓存 ，图片服务器。</li><li>将样式表放在顶部，脚本放在底部。</li><li>图片预加载。</li><li>缓存DOM节点查找的结果，减少IO读取操作。</li></ul><p>3、浏览器中输入url到显示页面的步骤</p><p>简洁版：</p><ol><li>浏览器将url交给DNS服务器进行域名解析，找到真实的IP地址，向服务器发起请求</li><li>服务器返回处理后的数据，浏览器接收文件（HTML、JS、CSS、图像等）</li><li>浏览器对加载后的（HTML、JS、CSS等）资源进行语法解析，建立相应的内部数据结构（HTML、DOM等）</li><li>载入解析后的资源文件，完成页面的渲染<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2></li></ol><p>1、<code>&lt;!DOCTYPE&gt;</code> 的作用</p><p><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知 Web 浏览器页面使用了哪种 HTML 版本，用什么文档类型规范来解析这个文档。</p><p>2、介绍HTML5</p><p>新特性：</p><ul><li>用于绘画的 canvas 元素</li><li>新增多媒体标签 video 和 audio </li><li>对本地离线存储的更好的支持</li><li>新的特殊内容元素，如 article、footer、header、nav、section</li><li>新的表单控件，如 date、time、email、url、search</li></ul><p>3、Canvas</p><p>HTML5的canvas元素使用JavaScript在网页上绘制图像。画布是一个矩形区域，可以使用JavaScript控制其每一像素。</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>1、盒模型</p><p>盒子模型构成：内容(<code>content</code>)、内边距(<code>padding</code>)、 边框(<code>border</code>)、外边距(<code>margin</code>)</p><ul><li>标准(<code>W3C</code>)盒模型： 元素宽度 = <code>width + padding + border + margin</code></li><li>怪异(<code>IE</code>)盒模型：元素宽度 = <code>width + margin</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span> </span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span></span><br></pre></td></tr></table></figure><p>2、选择器权重</p><p>优先级： <strong>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承</strong></p><p>3、动画animation</p><p><code>animation</code>是CSS3新增的属性，通过<code>@keyframes</code>声明动画的名称，通过<code>to</code>、<code>from</code>或百分比定义动画</p><table><thead><tr><th align="center"><strong>属性</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">@keyframes</td><td align="left">定义动画</td></tr><tr><td align="center">animation-name</td><td align="left">动画的名称（必写）</td></tr><tr><td align="center">animation-duration</td><td align="left">动画完成一个周期所花费的秒或毫秒，默认是0（必写）</td></tr><tr><td align="center">animation-timing-function</td><td align="left">动画的速度曲线，默认是ease</td></tr><tr><td align="center">animation-delay</td><td align="left">动画何时开始，默认是0</td></tr><tr><td align="center">animation-iteration-count</td><td align="left">动画播放的次数，默认是1，infinite无限播放</td></tr><tr><td align="center">animation-direction</td><td align="left">动画是否在下一周期逆向播放，默认是normal，alternate逆播放</td></tr><tr><td align="center">animation-play-state</td><td align="left">动画是否正在运行或暂停。默认是running，paused暂停</td></tr><tr><td align="center">animation-fill-mode</td><td align="left">动画结束后的状态，forwards停在结束位置，backwards回到起始位置</td></tr></tbody></table><p>使用animation简写所有动画属性，除了animation-play-state属性，书写顺序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation：动画名称 持续时间 运动曲线  何时开始  播放次数  是否反方向  动画起始或者结束的状态</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>1、事件代理，以及如何区分当前对象</p><p>事件代理又称为事件委托，将事件监听器设置在父节点上，利用冒泡原理进而影响每个子节点。</p><p>优点：给动态增加的子节点绑定事件，只操作了一次DOM，提高了程序性能。</p><p>通过<code>event.target</code>获得事件源，<code>event.srcElement</code>（IE 6-8）。</p><p>2、阻止冒泡和默认行为</p><p>阻止冒泡：<code>retutn false</code>，<code>event.stopPropagation()</code>（标准），<code>event.cancelBubble</code>（IE 6-8）</p><p>阻止默认行为：<code>return false</code>，<code>event.preventDefault()</code>（标准），`event.returnValue（IE 6-8）</p><p><code>return false</code> :</p><p>​    1.event.preventDefault()</p><p>​    2.event.stopPropagation()</p><p>​    3.停止回调函数执行并立即返回</p><p>3、捕获阶段</p><p>捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p><p>事件捕获：从DOM最顶层节点开始逐级向下传播到具体元素的过程</p><p>事件冒泡：从具体元素逐级向上传播到DOM最顶层结点的过程</p><p>4、基本数据类型</p><ul><li>基本数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></li><li>引用数据类型：<code>object</code>、<code>array</code>、<code>function</code></li></ul><p>JavaScript最新基本数据类型<code>BigInt</code>：<code>BigInt</code>数据类型是比 <code>Number</code>数据类型支持范围更大的整数值。</p><p>5、判断数组</p><ul><li><code>instanceof</code>方法：本质是判断原型</li><li><code>constructor</code>方法：返回对象相应的构造函数</li><li><code>Array.isArray()</code>方法</li></ul><p>6、0.1+0.2为什么不等于0.3</p><p>因为 <code>JS</code> 采用 <code>IEEE 754</code>双精度版本（<code>64</code>位），如下图。</p><img src="https://s1.ax1x.com/2020/08/07/afxB2n.jpg"><p>在这种标准下，0.1和0.2转换为二进制后是无限循环的，JS采用的浮点数标准会裁剪掉无限循环的数字，从而导致精度丢失。</p><p>7、this</p><table><thead><tr><th>调用方式</th><th>this指向</th></tr></thead><tbody><tr><td>普通函数</td><td>window</td></tr><tr><td>对象的方法</td><td>该方法所属对象</td></tr><tr><td>构造函数</td><td>实例对象，原型对象里的方法也指向实例对象</td></tr><tr><td>绑定事件函数</td><td>绑定事件对象</td></tr><tr><td>定时器函数</td><td>window</td></tr><tr><td>立即执行函数</td><td>window</td></tr></tbody></table><p>严格模式下全局作用域里函数中的<code>this</code>为<code>undefined</code>。</p><p>改变<code>this</code>指向的方法：<code>call()</code>、<code>bind()</code>、<code>apply()</code></p><p>8、new操作符过程</p><ul><li>创建一个空对象，并且 <code>this</code> 指向该对象，同时继承该函数的原型</li><li>将属性和方法加入到 <code>this</code> 引用的对象中</li><li>最后返回这个对象</li></ul><p>9、构造函数有返回值，new之后返回的是什么</p><p>如果构造函数<code>return</code>了一个新的“对象”，那么这个对象就会取代整个new出来的结果。</p><p>10、构造函数可不可以写成箭头函数</p><p>不可以，因为箭头函数没有<code>prototype</code>属性</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>1、sessionStorage</p><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>数据生命周期</td><td>一般由服务器生成，可以设置过期时间</td><td>除非被清理，否则一直存在</td><td>页面关闭就清理</td></tr><tr><td>数据存储大小</td><td><code>4K</code></td><td><code>5M</code></td><td><code>5M</code></td></tr><tr><td>与服务端通信</td><td>每次都会携带在 header 中，对于请求性能影响</td><td>不参与</td><td>不参与</td></tr></tbody></table><p>2、生命周期</p><p> Vue 实例从创建到销毁的过程就是生命周期。是开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁的一系列过程。</p><p>总共分为8个阶段创建前后，载入前后，更新前后，销毁前后</p><p>3、data为什么是函数</p><p>每个组件都是Vue的实例，data如果是一个引用类型时，不同组件之间会相互影响。</p><p>4、Vue是双向数据流还是单向数据流</p><p>Vue是单向数据流，即数据总是由父组件传递到子组件，子组件在其内部可以有自己维护的数据，但它法直接修改父组件的数据。</p><p>5、data数据改变之后为什么页面不刷新</p><p>页面初始化时，vue会遍历data对象所有的属性，并使用<code>object.defineProperty</code>把这些属性全部转化为<code>getter/setter</code>。直接改变数组元素，或者在对象中添加属性可以改变数据，但不会更新视图。</p><p>需要适应响应式的方法触发视图更新，如：<code>Object.assign()</code>，<code>Vue.set()</code>，<code>Array.push()</code></p><p>6、优化</p><ul><li>不要在模板里面写过多表达式</li><li>循环调用子组件时添加key</li><li>频繁切换的使用v-show，不频繁切换的使用v-if</li><li>尽量少用float，可以用flex</li><li>按需加载，可以用<code>require</code>或者<code>import()</code>按需加载需要的组件</li><li>路由懒加载</li><li>通过 <code>addEventListener</code>添加的事件在组件销毁时要用 <code>removeEventListener</code> 手动移除这些事件的监听</li><li>对图片进行压缩</li><li>使用 <code>CommonsChunkPlugin</code> 插件提取公共代码</li><li>提取组件的 CSS</li></ul><p>7、虚拟DOM以及使用虚拟DOM的好处</p><p><code>Virtual DOM</code>本质就是用一个原生的<strong>JS对象</strong>去描述一个DOM节点。是对真实DOM的一层抽象。</p><p>使用原生JS或JQ操作DOM效率很低，并且会产生一定的性能问题。例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。</p><p>虚拟DOM目的是减少实际DOM操作，解决浏览器性能问题。</p><p>虚拟DOM流程：</p><ol><li>用JS模拟DOM树并渲染</li><li>比较新旧DOM树，得到比较的差异对象</li><li>把差异对象应用到渲染的DOM树</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录面试过程中被问到的知识点&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>VS Code中Vue语法不高亮显示</title>
    <link href="http://yoursite.com/2020/08/06/VS-Code%E4%B8%ADVue%E8%AF%AD%E6%B3%95%E4%B8%8D%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2020/08/06/VS-Code%E4%B8%ADVue%E8%AF%AD%E6%B3%95%E4%B8%8D%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA/</id>
    <published>2020-08-06T11:59:16.000Z</published>
    <updated>2020-08-06T12:04:16.183Z</updated>
    
    <content type="html"><![CDATA[<p>VS Code自动更新后，Vue语法失去高亮显示（如下图），其他文件都正常。</p><a id="more"></a><p><img src="https://s1.ax1x.com/2020/08/06/agWOMV.png" alt=""></p><p>解决方法：重装vetur</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VS Code自动更新后，Vue语法失去高亮显示（如下图），其他文件都正常。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VS Code" scheme="http://yoursite.com/tags/VS-Code/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>移动端布局01-流式布局</title>
    <link href="http://yoursite.com/2020/07/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%8001-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2020/07/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%8001-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/</id>
    <published>2020-07-25T11:52:37.000Z</published>
    <updated>2020-07-25T12:00:55.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端基础"><a href="#移动端基础" class="headerlink" title="移动端基础"></a>移动端基础</h2><ul><li>移动端浏览器主要对webkit内核进行兼容</li><li>目前开发的移动端主要针对手机端开发</li><li>目前移动端碎片化比较严重，分辨率和屏幕尺寸大小不一</li><li>调试主要有三种方法<ul><li>使用Chrome DevTools（谷歌浏览器）的模拟手机调试</li><li>搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器</li><li>使用外网服务器，直接IP或域名访问</li></ul></li></ul><a id="more"></a><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>视口（viewport）就是浏览器显示页面内容的屏幕区域。分为布局视口、视觉视口和理想视口。</p><ol><li><p><strong>布局视口(layout viewport)</strong></p><p>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。<br>iOS, Android基本都将这个视口分辨率设置为 980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。</p></li><li><p><strong>视觉视口(visual viewport)</strong></p><p>是用户正在看到的网站的区域，用户可以通过缩放来操纵视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。</p></li><li><p><strong>理想视口(ideal viewport)</strong></p><p>理想视口对设备而言是最理想的视觉视口，是为了使网站在移动端有最理想的阅读宽度而设定的。需要手动添加<code>meta</code>标签告知浏览器。</p></li></ol><p><strong>meta标签</strong></p><p><code>meta</code>标签目的：使布局视口与理想视口宽度一致，即设备有多宽，布局视口就有多宽。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>width</code>: 指<code>viewport</code>，可以设置特殊值<code>device-width</code>。</li><li><code>user-scalable</code>: 用户是否可以缩放，值为yes 或 no （1或0）。</li><li><code>initial-scale</code>: 初始缩放比，要求为大于0的数字。</li><li><code>maximum-scale</code>: 最大缩放比，要求为大于0的数字。</li><li><code>minimum-scale</code>: 最小缩放比，要求为大于0的数字。</li></ul><p><strong>标准</strong>的viewport设置：</p><ul><li>视口宽度和设备保持一致</li><li>视口的默认缩放比例1.0</li><li>不允许用户自行缩放</li><li>最大允许的缩放比例1.0</li><li>最小允许的缩放比例1.0</li></ul><h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><p><strong>物理像素和物理像素比</strong></p><p><strong>物理像素</strong>：指屏幕显示的最小颗粒，是物理真实存在的，在手机出厂时就设置好了。在PC端页面，1px就等于1个物理像素，但是移动端并非如此。</p><p><strong>物理像素比</strong>：指1px能显示的物理像素点的个数，也成屏幕像素比。</p><blockquote><p>PC端和早期的手机屏幕以及普通手机屏幕: 1CSS像素 = 1 物理像素</p><p>Retina（视网膜屏幕）技术出现后，可以将更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。</p></blockquote><p><strong>多倍图</strong></p><p>对于一张 50px * 50px 的图片，在手机 Retina 屏中打开，按照2倍的物理像素比就会放大倍数，进而造成图片模糊。所以在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题。</p><p>通常使用二倍图， 部分还存在三倍图四倍图的情况，具体看实际开发需求。</p><p>解决方法：若要在移动端页面的到一张清晰的 50px*50px 的图片，可先准备一张 100px*100px 的图片并将其缩小至 50px*50px。</p><p><strong>背景缩放</strong></p><p><code>background-size</code> 属性规定背景图像的尺寸。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-size: 背景图片宽度 背景图片高度;</span><br></pre></td></tr></table></figure><p>参数： </p><ul><li>px: 规定具体宽高，只有一个参数即规定宽度，高度随宽度等比例缩放。</li><li>百分比: 百分比是对于父盒子而言的。</li><li><code>cover</code>: 等比例拉伸，背景图片完全覆盖父盒子，可能会导致图片显示不全。</li><li><code>contain</code>: 等比例拉伸，宽高有一边铺满父盒子时就不再拉伸，可能会导致盒子有空白区域。</li></ul><p><strong>二倍精灵图</strong></p><ul><li>在ps中把精灵图等比例缩放为原来的一半</li><li>然后测量大小和坐标</li><li>注意代码里面<code>background-size</code>也要写为精灵图原来宽度的一半</li></ul><h2 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h2><ol><li><p>单独制作移动端页面（主流）</p><p>通常情况下，网址域名前面加 <strong>m(mobile)</strong> 可以打开移动端。通过判断设备，如果是移动设备打开，则跳到<strong>移动端页面</strong>。</p></li><li><p>响应式页面兼容移动端</p><p>通过判断屏幕宽度来改变样式，以适应不同终端。</p></li></ol><h2 id="移动端技术"><a href="#移动端技术" class="headerlink" title="移动端技术"></a>移动端技术</h2><p>移动端浏览器基本以webkit内核为主，因此只需考虑webkit兼容性问题，且可使用 H5 标签和 CSS3 样式。浏览器的私有前缀只需要考虑添加 webkit 即可。</p><p><strong>CSS初始化</strong>：</p><p>推荐使用<code>normalize.css</code>，<a href="https://github.com/necolas/normalize.css/" target="_blank" rel="noopener">官方网址</a></p><p>特点：</p><ul><li>保护了有价值的默认值</li><li>修复了浏览器的bug</li><li>模块化</li><li>拥有详细的文档</li></ul><p><strong>CSS3盒子模型</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS3盒子模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="comment">/* 传统盒子模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>;</span><br></pre></td></tr></table></figure><p>传统盒子模型：盒子的宽度为width + border + padding </p><p>CSS3盒子模型：盒子的宽度为width </p><p>区别：</p><ul><li>移动端可以全部使用CSS3 盒子模型</li><li>PC端如果不考虑兼容性，选择 CSS3 盒子模型，否则就用传统模式。</li></ul><p><strong>特殊样式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS3盒子模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="comment">/* 需要清除点击高亮 设置为transparent 完成透明 */</span> </span><br><span class="line"><span class="selector-tag">-webkit-tap-highlight-color</span>: <span class="selector-tag">transparent</span>;</span><br><span class="line"><span class="comment">/* 在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式 */</span> </span><br><span class="line"><span class="selector-tag">-webkit-appearance</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="comment">/* 禁用长按页面时的弹出菜单 */</span></span><br><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">a</span> &#123; <span class="attribute">-webkit-touch-callout</span>: none; &#125;</span><br></pre></td></tr></table></figure><h2 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h2><p><strong>技术选型</strong></p><p>单独制作移动端页面：</p><ul><li>流式布局（百分比布局）</li><li>flex弹性布局（推荐）</li><li>less + rem + 媒体查询布局</li><li>混合布局</li></ul><p>响应式页面兼容移动端：</p><ul><li>媒体查询</li><li>Bootstarp</li></ul><h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><p>流式布局就是百分比布局，也称固定像素布局。将盒子的<strong>宽度</strong>设置成百分比，从而根据屏幕的宽度进行伸缩，不受固定像素的限制，内容向两侧填充。</p><p>为了保护内容，还可以规定最大值和最小值：<code>max-width</code>，<code>min-width</code>，<code>max-height</code>，<code>min-height</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;移动端基础&quot;&gt;&lt;a href=&quot;#移动端基础&quot; class=&quot;headerlink&quot; title=&quot;移动端基础&quot;&gt;&lt;/a&gt;移动端基础&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;移动端浏览器主要对webkit内核进行兼容&lt;/li&gt;
&lt;li&gt;目前开发的移动端主要针对手机端开发&lt;/li&gt;
&lt;li&gt;目前移动端碎片化比较严重，分辨率和屏幕尺寸大小不一&lt;/li&gt;
&lt;li&gt;调试主要有三种方法&lt;ul&gt;
&lt;li&gt;使用Chrome DevTools（谷歌浏览器）的模拟手机调试&lt;/li&gt;
&lt;li&gt;搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器&lt;/li&gt;
&lt;li&gt;使用外网服务器，直接IP或域名访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="移动端布局" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue笔记07-Axios</title>
    <link href="http://yoursite.com/2020/07/23/Vue/Vue%E7%AC%94%E8%AE%B007-Axios/"/>
    <id>http://yoursite.com/2020/07/23/Vue/Vue%E7%AC%94%E8%AE%B007-Axios/</id>
    <published>2020-07-23T12:08:04.000Z</published>
    <updated>2020-07-23T12:10:16.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Axios是一个基于promise的HTTP库，适用于浏览器和node.js。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>浏览器端发起XMLHttpRequests请求</li><li>node端发起http请求</li><li>支持Promise API</li><li>拦截请求和返回</li><li>转化请求和返回（数据）</li><li>取消请求</li><li>自动转化json数据</li><li>客户端支持抵御XSRF（跨站请求伪造）</li></ul><a id="more"></a><h2 id="使用和配置"><a href="#使用和配置" class="headerlink" title="使用和配置"></a>使用和配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定url创建请求</span></span><br><span class="line">axios.get(<span class="string">'http://123.207.32.32:8000/home/data?type=pop&amp;page=1'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.get(<span class="string">'/http://123.207.32.32:8000/home/data'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      type: <span class="string">'pop'</span>,</span><br><span class="line">      page: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><p><code>axios(config)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  url: <span class="string">'http://123.207.32.32:8000/home/multidata'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">'http://123.207.32.32:8000/home/data'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    <span class="comment">// 参数拼接 type=pop&amp;page=1</span></span><br><span class="line">    type: <span class="string">'pop'</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios支持多种请求方式"><a href="#axios支持多种请求方式" class="headerlink" title="axios支持多种请求方式"></a>axios支持多种请求方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios(config)</span><br><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[,config])</span><br><span class="line">axios.delete(url[,config])</span><br><span class="line">axios.head(url[,data[,config])</span><br><span class="line">axios.post(url[,data[,config])</span><br><span class="line">axios.put(url[,data[,config])</span><br><span class="line">axios.patch(url[,data[,config])</span><br></pre></td></tr></table></figure><h3 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h3><p><code>axios.all(iterable)</code>可以放入多个请求，返回的结果是一个数组。</p><p><code>axios.spread(callback)</code>：将数组<code>[res1, res2]</code>展开为res1, res2。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">'http://123.207.32.32:8000/home/multidata'</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">'http://123.207.32.32:8000/home/data'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">'pop'</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>在开发中一些参数是固定的，所以可以进行抽取，也可以利用axios的全局配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'http://123.207.32.32:8000'</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>常见配置选项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求地址</span></span><br><span class="line">url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求类型,默认是 get</span></span><br><span class="line">method: <span class="string">'get'</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动加在url前面，除非url是一个绝对 URL</span></span><br><span class="line">baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求前的数据处理</span></span><br><span class="line">transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;&#125;],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求后的数据处理</span></span><br><span class="line">transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;&#125;],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的请求头</span></span><br><span class="line">headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// URL参数, 查询对象(query), 针对get请求</span></span><br><span class="line">params: &#123;</span><br><span class="line">  ID: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//  params序列化函数</span></span><br><span class="line">paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// request body请求体, 针对post请求</span></span><br><span class="line">data: &#123;</span><br><span class="line">  key: <span class="string">'a'</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定请求超时的毫秒数</span></span><br><span class="line">timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示跨域请求时是否需要使用凭证(token), 默认为false</span></span><br><span class="line">withCredentials: <span class="literal">false</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义请求处理</span></span><br><span class="line">adapter: <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject, config</span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 身份验证信息</span></span><br><span class="line">auth: &#123;</span><br><span class="line">  username: <span class="string">'a'</span>,</span><br><span class="line">  password: <span class="string">'123'</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器响应的数据类型：json(默认)/blob/document/arraybuffer/text/steam</span></span><br><span class="line">responseType: <span class="string">'json'</span>,</span><br></pre></td></tr></table></figure><h2 id="实例和模块封装"><a href="#实例和模块封装" class="headerlink" title="实例和模块封装"></a>实例和模块封装</h2><h3 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h3><p>需要请求多种url时，可能会有不同的配置要求，通过<code>axios.create</code>创建实例满足不同的请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'http://123.207.32.32:8000'</span>,</span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line">instance(&#123;</span><br><span class="line">  url: <span class="string">'/home/multidata'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h3><p>给每个要请求数据的组件引入axios，一旦axios出现问题，需要逐个修改。所以封装一个模块，组件需要请求数据时，就使用此模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  network/request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'http://123.207.32.32:8000'</span>,</span><br><span class="line">    timeout: <span class="number">3000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 真实请求，返回的是Promise</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">'/home/multidata'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 请求成功, 处理操作</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 请求失败, 处理操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 响应成功, 处理操作</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 响应失败, 处理操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>请求拦截的作用：</p><ul><li>config中一些信息不符合服务器的需求。</li><li>发送网络请求时希望在界面上显示一个请求的图标。</li><li>一些网络请求(如登录)，必须携带一些特殊信息。</li></ul><p>响应拦截的作用：</p><ul><li>对请求的数据进行过滤。</li><li>根据错误码跳转到不同的提示页面。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Axios是一个基于promise的HTTP库，适用于浏览器和node.js。&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;浏览器端发起XMLHttpRequests请求&lt;/li&gt;
&lt;li&gt;node端发起http请求&lt;/li&gt;
&lt;li&gt;支持Promise API&lt;/li&gt;
&lt;li&gt;拦截请求和返回&lt;/li&gt;
&lt;li&gt;转化请求和返回（数据）&lt;/li&gt;
&lt;li&gt;取消请求&lt;/li&gt;
&lt;li&gt;自动转化json数据&lt;/li&gt;
&lt;li&gt;客户端支持抵御XSRF（跨站请求伪造）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue笔记06-Vuex</title>
    <link href="http://yoursite.com/2020/07/21/Vue/Vue%E7%AC%94%E8%AE%B006-Vuex/"/>
    <id>http://yoursite.com/2020/07/21/Vue/Vue%E7%AC%94%E8%AE%B006-Vuex/</id>
    <published>2020-07-21T13:48:15.000Z</published>
    <updated>2020-07-21T13:52:33.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Vuex是一个专为Vue.js应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式存储管理</strong>应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>可以简单的将其看成把多个组件共享的变量全部存储在一个对象里面。再将这个对象放在顶层的Vue实例中，让其他组件可以使用。</p><a id="more"></a><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="单界面状态管理"><a href="#单界面状态管理" class="headerlink" title="单界面状态管理"></a>单界面状态管理</h3><p><img src="https://s1.ax1x.com/2020/07/17/U6z6mT.md.png" style="zoom: 60%; margin-left: 0" /> </p><ul><li>State：状态（可理解为data中的属性）</li><li>View：视图层，可以针对State的变化，显示不同的信息。</li><li>Actions：主要是用户的各种操作：点击、输入等，会导致状态的改变。</li></ul><h3 id="多界面状态管理"><a href="#多界面状态管理" class="headerlink" title="多界面状态管理"></a>多界面状态管理</h3><p>多个组件共享状态，把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p><img src="https://s1.ax1x.com/2020/07/18/UcCLrt.png" style="zoom:95%;" /><ol><li>组件可以直接通过Mutations改变State。</li><li>存在异步操作时，需要将异步操作在Action中完成，再提交到Mutations。</li><li>提交mutation是更改状态的唯一方法。</li><li>devtools是浏览器插件，可以记录对State的修改。</li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在store/index.js 文件中创建并导出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    decrement(state) &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;,</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在Vue实例中挂载：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store,   <span class="comment">// // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>在其他Vue组件中通过 <code>this.$store</code> 来获取状态对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 store.state 来获取状态对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$store.state.count) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 store.commit 方法触发状态变更</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'decrement'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>通过提交mutation的方式，而非直接改变store.state.count。因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</p></blockquote><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>State</li><li>Getters</li><li>Mutation</li><li>Action</li><li>Module</li></ul><h3 id="State单一状态树"><a href="#State单一状态树" class="headerlink" title="State单一状态树"></a>State单一状态树</h3><p>Vuex使用<strong>单一状态树</strong>，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源SSOT (Single Source of Truth) 而存在。这也意味着，每个应用将仅仅包含一个 store 实例。</p><p>单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><p>在组件中使用 (需要在根组件里“注入”)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.count</span><br></pre></td></tr></table></figure><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>有多个组件需要用到某属性时，Vuex允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter接受stat作为其第一个参数，也可以接受其他getter作为第二个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;,</span><br><span class="line">    doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在组件中访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过让getter返回一个函数，来实现给getter传参。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById(state) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$store.getters.getTodoById(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>更改Vuex的store中的状态的<strong>唯一方法是提交mutation</strong>。</p><p>mutation包括两部分： <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。</p><p>事件类型为字符串，而这个回调函数就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在组件中使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">increament() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提交载荷</strong>，可以向 <code>store.commit</code> 中传入额外的参数，即mutation的载荷（payload）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>载荷也可以是一个对象，这样可以包含多个字段并且记录的mutation会更易读：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>提交风格</strong></p><p>提交mutation的另一种方式是直接使用包含 <code>type</code> 属性的对象，当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变（同上）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>响应规则</strong></p><p>想要实现响应式，需要与使用Vue一样遵守一些注意事项：</p><ul><li>最好提前在store中初始化好所有所需属性。</li><li>当需要在对象上添加新属性时，有两种方式<ul><li>使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code></li><li>以新对象替换老对象。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    info: &#123;</span><br><span class="line">      name: <span class="string">'lwt'</span>,</span><br><span class="line">      age: <span class="number">23</span>,</span><br><span class="line">      height: <span class="number">1.65</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 非响应式</span></span><br><span class="line">    state.info[<span class="string">'address'</span>] = <span class="string">'China'</span> </span><br><span class="line">    <span class="comment">// 响应式</span></span><br><span class="line">    Vue.set(state.info, <span class="string">'address'</span>, <span class="string">'China'</span>)</span><br><span class="line"><span class="comment">// 非响应式</span></span><br><span class="line">    <span class="keyword">delete</span> state.info.height </span><br><span class="line"><span class="comment">// 响应式</span></span><br><span class="line">    Vue.delete(state.info, <span class="string">'height'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>使用常量替代Mutation事件类型</strong></p><p>在store文件夹下新建<code>mutation-types.js</code>在其中定义我们的常量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UPDATE_INFO = <span class="string">'UPDATE_INFO'</span></span><br></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  store/index.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; UPDATE_INFO &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [UPDATE_INFO] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; UPDATE_INFO &#125; <span class="keyword">from</span> <span class="string">'./store/mutation-types'</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  updateInfo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(UPDATE_INFO)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步函数</strong></p><p>通常情况下, Vuex要求我们Mutation中的方法必须是同步方法。主要的原因是当我们使用devtools时，可以devtools可以帮助我们捕捉mutation的快照。但是如果是异步操作，那么devtools将不能很好的追踪这个操作什么时候会被完成。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action类似于mutation，不同在于：</p><ul><li>Action提交的是mutation，而不是直接变更状态。</li><li>Action可以包含任意异步操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action函数接受一个与store实例具有相同方法和属性的<strong>context对象</strong>，因此可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p><p><strong>分发 Action</strong></p><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (context) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>, payload)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>.store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">     amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>.store.dispatch(&#123;</span><br><span class="line">     type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">    amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组合Action (Promise)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addInfo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex允许我们将store分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure><p>module<strong>局部状态</strong></p><ul><li>对于模块内部的mutation和getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</li><li>对于模块内部的action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>。</li><li>对于模块内部的getter，根节点状态会作为第三个参数暴露出来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 state 对象是模块的局部状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 state 对象是模块的局部状态</span></span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="comment">// &#123; state, commit, rootState &#125;解构赋值</span></span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="comment">// 第二个参数gettters可以获取其他getters</span></span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：  虽然 doubleCount 和 increment 都是定义在模块内部的，但是在调用的时候，依然是通过this.$store来直接调用。</p></blockquote><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>对于大型应用，我们会希望把Vuex相关代码分割到模块中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... <span class="comment"># 抽取出API请求</span></span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          <span class="comment"># 我们组装模块并导出 store 的地方</span></span><br><span class="line">    ├── actions.js        <span class="comment"># 根级别的 action</span></span><br><span class="line">    ├── mutations.js      <span class="comment"># 根级别的 mutation</span></span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       <span class="comment"># 购物车模块</span></span><br><span class="line">        └── products.js   <span class="comment"># 产品模块</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Vuex是一个专为Vue.js应用程序开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;。它采用&lt;strong&gt;集中式存储管理&lt;/strong&gt;应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;p&gt;可以简单的将其看成把多个组件共享的变量全部存储在一个对象里面。再将这个对象放在顶层的Vue实例中，让其他组件可以使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue笔记05-Vue Router</title>
    <link href="http://yoursite.com/2020/07/19/Vue/Vue%E7%AC%94%E8%AE%B005-Vue-Router/"/>
    <id>http://yoursite.com/2020/07/19/Vue/Vue%E7%AC%94%E8%AE%B005-Vue-Router/</id>
    <published>2020-07-19T13:52:50.000Z</published>
    <updated>2020-09-25T13:14:13.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由介绍"><a href="#路由介绍" class="headerlink" title="路由介绍"></a>路由介绍</h2><p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p><p><strong>后端路由</strong>：页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好对应的HTML页面, 并且将页面返回给客户顿。</p><p><strong>前后端分离</strong>：后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中。</p><p><strong>SPA(单页面富应用)</strong>：前后端分离的基础上加了一层前端路由，整个网站只有一个html页面，改变URL时，页面不进行整体的刷新。</p><a id="more"></a><h3 id="URL的hash"><a href="#URL的hash" class="headerlink" title="URL的hash"></a>URL的hash</h3><p>URL的hash也就是锚点(#), 本质上是改变<code>window.location</code>的<code>href</code>属性。可以通过直接赋值<code>location.hash</code>来改变<code>href</code>， 但是页面不发生刷新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.hash &#x3D; &#39;&#x2F;foo&#39;</span><br></pre></td></tr></table></figure><h3 id="HTML5的history"><a href="#HTML5的history" class="headerlink" title="HTML5的history"></a>HTML5的history</h3><p>history接口是HTML5新增的，它有五种模式改变URL而不刷新页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; history.pushState(data, title, targetURL);</span><br><span class="line">history.pushState(&#123;&#125;, &#39;&#39;, &#39;&#x2F;home&#39;)</span><br><span class="line">history.back()</span><br><span class="line">history.forward()</span><br><span class="line">&#x2F;&#x2F; history.replaceState(data, title, targetURL);</span><br><span class="line">history.replaceState()</span><br><span class="line">history.go()</span><br></pre></td></tr></table></figure><ul><li><code>history.pushState</code>：多次push相当于入栈。</li><li><code>history.back()</code>：等价于 <code>history.go(-1)</code>。</li><li><code>history.forward()</code>：等价于 <code>history.go(1)</code>。</li><li><code>history.replaceState</code>：替换，无法前进和后退</li><li><code>history.go</code>：基于<code>history.pushState</code>，括号内正值前进，负值后退。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>安装vue-router：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue<span class="literal">-router</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>配置：</p><ol><li>导入路由对象，调用<code>Vue.use()</code></li><li>创建路由实例，传入路由映射配置</li><li>在Vue实例中挂载路由实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入组件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由映射</span></span><br><span class="line"><span class="keyword">const</span> routes = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出router实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Vue实例中挂载</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>创建路由组件</li><li>配置组件和路径的映射关系</li><li>通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code>使用路由</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Home.vue 创建Home组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;主页&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;主页内容&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Home&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style  scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js 配置路由映射</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// 导入Home组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../components/Home.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装vue-router组件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置路由映射</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,  <span class="comment">// 路由地址</span></span><br><span class="line">    component: Home  <span class="comment">// 组件名</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// App.vue 使用路由</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>补充：<br><code>&lt;router-link&gt;</code>:  该标签是一个vue-router中已经内置的组件，最终会被渲染成一个<code>&lt;a&gt;</code>标签。<br><code>&lt;router-view&gt;</code>：该标签用于占位，会根据当前的路径，动态渲染出不同的组件。</p><h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><h3 id="路由默认路径"><a href="#路由默认路径" class="headerlink" title="路由默认路径"></a>路由默认路径</h3><p>使用重定向让路径默认跳转到另一个路径。<br>如将根路径重定向到<code>/home</code>的路径下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,           <span class="comment">// path配置了根路径</span></span><br><span class="line">    redirect: <span class="string">'/home'</span>    <span class="comment">// 重定向</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="HTML5的History模式"><a href="#HTML5的History模式" class="headerlink" title="HTML5的History模式"></a>HTML5的History模式</h3><p>改变路径的方式有两种：URL的hash 和 HTML5的history。<br>默认情况下, 路径的改变使用的URL的hash。<br>修改为history模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">'history'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="router-link属性"><a href="#router-link属性" class="headerlink" title="router-link属性"></a>router-link属性</h3><ul><li><p><code>to</code>： 跳转到指定路径。</p></li><li><p><code>tag</code>： 指定<code>&lt;router-link&gt;</code>最后渲染成什么元素。</p></li><li><p><code>replace</code>： 不会留下history记录，即无法使用后退和前进</p></li><li><p><code>active-class</code>： 当<code>&lt;router-link&gt;</code>对应的路由匹配成功时，会自动给当前元素设置一个<code>router-link-active</code>的属性。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/home'</span> <span class="attr">tag</span>=<span class="string">'button'</span> <span class="attr">replace</span> <span class="attr">active-class</span>=<span class="string">'active'</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/about'</span> <span class="attr">tag</span>=<span class="string">'button'</span> <span class="attr">replace</span> <span class="attr">active-class</span>=<span class="string">'active'</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用linkActiveClass统一修改active-class类名</span></span><br><span class="line"><span class="comment">// router实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  linkActiveClass: <span class="string">'active'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由代码跳转"><a href="#路由代码跳转" class="headerlink" title="路由代码跳转"></a>路由代码跳转</h3><p>当页面跳转还需要执行对应js代码时，就需要使用代码跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;homeBtn&quot;&gt;首页&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;aboutBtn&quot;&gt;关于&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    homeBtn() &#123;</span><br><span class="line">      &#x2F;&#x2F; push 对应 pushState</span><br><span class="line">      &#x2F;&#x2F; this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">      this.$router.replace(&#39;&#x2F;home&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    aboutBtn() &#123;</span><br><span class="line">      &#x2F;&#x2F; push 对应 pushState</span><br><span class="line">      &#x2F;&#x2F; this.$router.push(&#39;&#x2F;about&#39;)</span><br><span class="line">      this.$router.replace(&#39;&#x2F;about&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>一个页面的path路径可能是不确定的，如进入用户界面时，可以在路径后加上用户ID (/user/id)。这种path和Component的匹配关系就是动态路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 动态路径参数，以冒号开头</span></span><br><span class="line">    path: <span class="string">'/user/:userId'</span>,</span><br><span class="line">    component: User</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'/user/'+userId"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      userId: <span class="string">'lsy'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$route.params.userId&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p><p>方法一： 结合Vue的异步组件和Webpack的代码分割功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="built_in">require</span>.ensure([<span class="string">'../components/Home.vue'</span>], () =&gt; &#123; resolve(<span class="built_in">require</span>(<span class="string">'../components/Home.vue'</span>)) &#125;)&#125;;</span><br></pre></td></tr></table></figure><p>方法二： AMD写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'../components/About.vue'</span>], resolve);</span><br></pre></td></tr></table></figure><p>方法三： ES6中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Home.vue'</span>)</span><br></pre></td></tr></table></figure><p>未使用懒加载，打包后js文件如下：</p><p><img src="https://s1.ax1x.com/2020/07/17/UyfLLV.png" alt=""></p><p>使用懒加载后：</p><p><img src="https://s1.ax1x.com/2020/07/17/UyhRp9.png" alt=""></p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><ol><li>创建对应的子组件, 并且在路由映射中配置对应的子路由.</li><li>在组件内部使用<code>&lt;router-link&gt;</code> 和 <code>&lt;router-view&gt;</code>标签.</li></ol><p><img src="https://s1.ax1x.com/2020/07/17/Uy4m7T.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idnex.js</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  component: Home,</span><br><span class="line">  <span class="comment">// 嵌套</span></span><br><span class="line">  children: [    </span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,         <span class="comment">// 重定向</span></span><br><span class="line">      redirect: <span class="string">'news'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'news'</span>,</span><br><span class="line">      component: News</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      path: <span class="string">'message'</span>, </span><br><span class="line">      component: Message </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>传递参数主要有两种类型: params 和 query。<br>每种类型都有<code>&lt;router-link&gt;</code>的和JavaScript代码两种方式。</p><h3 id="params类型"><a href="#params类型" class="headerlink" title="params类型"></a>params类型</h3><ul><li>配置路由格式： /router/:id</li><li>传递的方式： 在path后面跟上对应的值</li><li>传递后形成的路径： /router/123， /router/abc</li></ul><p><code>&lt;router-link&gt;</code>方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'/user/'+userId"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript代码方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  userBtn() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/user/'</span> + <span class="keyword">this</span>.userId)</span><br><span class="line">    <span class="comment">// 对于命名路由</span></span><br><span class="line">    <span class="keyword">this</span>.$router.push(&#123; </span><br><span class="line">      name: <span class="string">'user'</span>, </span><br><span class="line">      params: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="query类型"><a href="#query类型" class="headerlink" title="query类型"></a>query类型</h3><p>传递后形成的路径： /router?id=123</p><p><code>&lt;router-link&gt;</code>方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;path: '/profile', query: &#123;name: 'lsy',age: 18, height: 1.66&#125;&#125;"</span>&gt;</span>简介<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript代码方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  profileBtn() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">      path: <span class="string">'profile'</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        name: <span class="string">'lsy'</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        order: <span class="number">1.66</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p></blockquote><p><a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">参考文档</a></p><h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><p>通过<code>$route</code>对象获取参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$route.params.userId&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item of $route.query"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">     &#123;&#123; item &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="route和-router"><a href="#route和-router" class="headerlink" title="$route和$router"></a>$route和$router</h3><ul><li><code>$router</code>为VueRouter实例，想要导航到不同URL，则使用<code>$router.push</code>方法</li><li><code>$route</code>为当前router跳转对象 (活跃对象)，可以获取name、path、query、params等 </li></ul><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p><code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航，即监听路由的进入和离开。有全局的、单个路由独享的、组件级的。</p><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>全局守卫有<code>beforeEach</code> 和 <code>afterEach</code>的钩子函数，它们会在路由改变前和改变后触发。</p><p><strong>全局前置守卫</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">                              </span><br><span class="line"><span class="comment">// 使用router.beforeEach注册一个全局前置守卫</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>to: Route</code>: 即将要进入的目标 <a href="https://router.vuejs.org/zh/api/#路由对象" target="_blank" rel="noopener">路由对象</a></li><li><code>from: Route</code>: 当前导航正要离开的路由</li><li><code>next: Function</code>: 一定要调用次方法。执行效果依赖 <code>next</code> 方法的调用参数。<ul><li><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li><li><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li><li><code>next(&#39;/&#39;)</code> 或者 <code>next({ path: &#39;/&#39; })</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象。</li></ul></li></ul><p><strong>全局后置钩子</strong>：</p><p>和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="[https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局前置守卫)">导航守卫参考</a></p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p><p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;keep-alive&gt;</code>属性：</p><ul><li>include： 字符串或正则表达，只有匹配的组件会被缓存。</li><li>exclude： 字符串或正则表达式，任何匹配的组件都不会被缓存。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以直接使用组件的name属性，多个值用逗号隔开，不能加空格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">'Profile,User'</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;路由介绍&quot;&gt;&lt;a href=&quot;#路由介绍&quot; class=&quot;headerlink&quot; title=&quot;路由介绍&quot;&gt;&lt;/a&gt;路由介绍&lt;/h2&gt;&lt;p&gt;在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后端路由&lt;/strong&gt;：页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好对应的HTML页面, 并且将页面返回给客户顿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前后端分离&lt;/strong&gt;：后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPA(单页面富应用)&lt;/strong&gt;：前后端分离的基础上加了一层前端路由，整个网站只有一个html页面，改变URL时，页面不进行整体的刷新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue笔记04-CLI</title>
    <link href="http://yoursite.com/2020/07/19/Vue/Vue%E7%AC%94%E8%AE%B004-CLI/"/>
    <id>http://yoursite.com/2020/07/19/Vue/Vue%E7%AC%94%E8%AE%B004-CLI/</id>
    <published>2020-07-19T13:48:56.000Z</published>
    <updated>2020-07-19T13:54:03.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CLI (Command-Line Interface)命令行界面,，俗称<strong>脚手架</strong>。使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置。</p><p>Vue CLI 基于Node和Webpack。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v12.14.1</span><br><span class="line">$ webpack -v</span><br><span class="line">3.6.0</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> @vue/cli</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure><p>查看版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue -<span class="literal">-version</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>拉取 2.x 模板 (旧版本)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="comment"># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure><p>初始化项目</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Vue CLI2初始化项目</span></span><br><span class="line">vue init webpack my<span class="literal">-project</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Vue CLI3/4初始化项目</span></span><br><span class="line">vue create my<span class="literal">-project</span></span><br></pre></td></tr></table></figure><h3 id="Runtime-Compiler和Runtime-only"><a href="#Runtime-Compiler和Runtime-only" class="headerlink" title="Runtime-Compiler和Runtime-only"></a>Runtime-Compiler和Runtime-only</h3><p>Vue程序运行过程：</p><p><img src="https://s1.ax1x.com/2020/07/16/UrpzQK.png" alt=""></p><ul><li>Runtime-Compiler ： template -&gt; ast (抽象语法树) -&gt; render -&gt; virtual dom -&gt; 真实DOM</li><li>Runtime-only ： render -&gt; virtual dom -&gt; 真实DOM</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime-Compiler </span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    components: &#123; App &#125;,</span><br><span class="line">    template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime-only</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="render函数的使用"><a href="#render函数的使用" class="headerlink" title="render函数的使用"></a>render函数的使用</h3><p>该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>(虚拟节点)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render: (<span class="function"><span class="params">createElement</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 方法一：return createElement('标签', &#123;标签的属性&#125;, ['内容'])</span></span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'h2'</span>,</span><br><span class="line">             &#123;<span class="attr">class</span>: <span class="string">'box'</span>&#125;,</span><br><span class="line">             [<span class="string">'Hello World'</span>, createElement(<span class="string">'button'</span>, [<span class="string">'按钮'</span>])])</span><br><span class="line">    <span class="comment">// 2. 方法二：传入组件对象</span></span><br><span class="line"><span class="keyword">return</span> createElement(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="CLI3"><a href="#CLI3" class="headerlink" title="CLI3"></a>CLI3</h2><ul><li>vue-cli 3是基于webpack 4打造，vue-cli 2 还是webapck 3</li><li>vue-cli 3的设计原则是“0配置”，移除的配置文件根目录下的，build和config等目录</li><li>vue-cli 3提供了 vue ui 命令提供了可视化配置，更加人性化</li><li>移除了static文件夹，新增了public文件夹，并且index.html移动到public中</li></ul><p>查看配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;CLI (Command-Line Interface)命令行界面,，俗称&lt;strong&gt;脚手架&lt;/strong&gt;。使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置。&lt;/p&gt;
&lt;p&gt;Vue CLI 基于Node和Webpack。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ node -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v12.14.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ webpack -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.6.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Hexo发布成功博客不显示</title>
    <link href="http://yoursite.com/2020/07/17/Hexo%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2020/07/17/Hexo%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%98%BE%E7%A4%BA/</id>
    <published>2020-07-17T14:42:55.000Z</published>
    <updated>2021-04-17T02:05:26.576Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：</p><p><code>hexo s</code>在本地服务器上可以查看到新发布的文章，<code>hexo d</code>发布成功无报错信息。但是在博客上无法显示新发布的文章。</p><p>尝试删除blog文件夹下的<code>.deploy_git</code> 并重新部署，依旧无法显示。</p><p>最后发现是github登录邮箱设置成了<code>private</code>，所以更新的内容无法通过<code>hexo d</code>发布到github。</p><a id="more"></a><p>解决方法：</p><p>打开github设置，setting =&gt; email =&gt; 取消勾选<code>Keep my email addresses private</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hexo s&lt;/code&gt;在本地服务器上可以查看到新发布的文章，&lt;code&gt;hexo d&lt;/code&gt;发布成功无报错信息。但是在博客上无法显示新发布的文章。&lt;/p&gt;
&lt;p&gt;尝试删除blog文件夹下的&lt;code&gt;.deploy_git&lt;/code&gt; 并重新部署，依旧无法显示。&lt;/p&gt;
&lt;p&gt;最后发现是github登录邮箱设置成了&lt;code&gt;private&lt;/code&gt;，所以更新的内容无法通过&lt;code&gt;hexo d&lt;/code&gt;发布到github。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客搭建" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
</feed>
